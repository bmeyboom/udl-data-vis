(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!******************************************************************************************************!*\
  !*** /home/daniil/actionEngine/loaders.gl/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!***************************************************************************************************!*\
  !*** /home/daniil/actionEngine/loaders.gl/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/index.js":
/*!*******************************************************************************************!*\
  !*** /home/daniil/actionEngine/loaders.gl/node_modules/@probe.gl/stats/dist/esm/index.js ***!
  \*******************************************************************************************/
/*! exports provided: Stats, Stat, _getHiResTimestamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_stats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stats */ "../../node_modules/@probe.gl/stats/dist/esm/lib/stats.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stats", function() { return _lib_stats__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_stat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/stat */ "../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stat", function() { return _lib_stat__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hi-res-timestamp */ "../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getHiResTimestamp", function() { return _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"]; });




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js":
/*!**********************************************************************************************!*\
  !*** /home/daniil/actionEngine/loaders.gl/node_modules/@probe.gl/stats/dist/esm/lib/stat.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stat; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/hi-res-timestamp */ "../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js");




var Stat = function () {
  function Stat(name, type) {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Stat);

    this.name = name;
    this.type = type;
    this.sampleSize = 1;
    this.reset();
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Stat, [{
    key: "setSampleSize",
    value: function setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
  }, {
    key: "incrementCount",
    value: function incrementCount() {
      this.addCount(1);
      return this;
    }
  }, {
    key: "decrementCount",
    value: function decrementCount() {
      this.subtractCount(1);
      return this;
    }
  }, {
    key: "addCount",
    value: function addCount(value) {
      this._count += value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "subtractCount",
    value: function subtractCount(value) {
      this._count -= value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "addTime",
    value: function addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "timeStart",
    value: function timeStart() {
      this._startTime = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"])();
      this._timerPending = true;
      return this;
    }
  }, {
    key: "timeEnd",
    value: function timeEnd() {
      if (!this._timerPending) {
        return this;
      }

      this.addTime(Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"])() - this._startTime);
      this._timerPending = false;

      this._checkSampling();

      return this;
    }
  }, {
    key: "getSampleAverageCount",
    value: function getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
  }, {
    key: "getSampleAverageTime",
    value: function getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
  }, {
    key: "getSampleHz",
    value: function getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
  }, {
    key: "getAverageCount",
    value: function getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
  }, {
    key: "getAverageTime",
    value: function getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
  }, {
    key: "getHz",
    value: function getHz() {
      return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
  }, {
    key: "_checkSampling",
    value: function _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  }]);

  return Stat;
}();


//# sourceMappingURL=stat.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/lib/stats.js":
/*!***********************************************************************************************!*\
  !*** /home/daniil/actionEngine/loaders.gl/node_modules/@probe.gl/stats/dist/esm/lib/stats.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stats; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _stat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat */ "../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js");




var Stats = function () {
  function Stats(_ref) {
    var id = _ref.id,
        stats = _ref.stats;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Stats);

    this.id = id;
    this.stats = {};

    this._initializeStats(stats);

    Object.seal(this);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Stats, [{
    key: "get",
    value: function get(name) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
      return this._getOrCreate({
        name: name,
        type: type
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var key in this.stats) {
        this.stats[key].reset();
      }

      return this;
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      for (var key in this.stats) {
        fn(this.stats[key]);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      var table = {};
      this.forEach(function (stat) {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
  }, {
    key: "_initializeStats",
    value: function _initializeStats() {
      var _this = this;

      var stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      stats.forEach(function (stat) {
        return _this._getOrCreate(stat);
      });
    }
  }, {
    key: "_getOrCreate",
    value: function _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }

      var name = stat.name,
          type = stat.type;

      if (!this.stats[name]) {
        if (stat instanceof _stat__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          this.stats[name] = stat;
        } else {
          this.stats[name] = new _stat__WEBPACK_IMPORTED_MODULE_2__["default"](name, type);
        }
      }

      return this.stats[name];
    }
  }, {
    key: "size",
    get: function get() {
      return Object.keys(this.stats).length;
    }
  }]);

  return Stats;
}();


//# sourceMappingURL=stats.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js":
/*!************************************************************************************************************!*\
  !*** /home/daniil/actionEngine/loaders.gl/node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getHiResTimestamp; });
function getHiResTimestamp() {
  var timestamp;

  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    var timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
//# sourceMappingURL=hi-res-timestamp.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!****************************************************************************!*\
  !*** /home/daniil/actionEngine/loaders.gl/node_modules/process/browser.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../gis/src/index.js":
/*!***************************!*\
  !*** ../gis/src/index.js ***!
  \***************************/
/*! exports provided: geojsonToBinary, binaryToGeoJson, transformBinaryCoords, transformGeoJsonCoords */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_geojson_to_binary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/geojson-to-binary */ "../gis/src/lib/geojson-to-binary.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geojsonToBinary", function() { return _lib_geojson_to_binary__WEBPACK_IMPORTED_MODULE_0__["geojsonToBinary"]; });

/* harmony import */ var _lib_binary_to_geojson__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/binary-to-geojson */ "../gis/src/lib/binary-to-geojson.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "binaryToGeoJson", function() { return _lib_binary_to_geojson__WEBPACK_IMPORTED_MODULE_1__["binaryToGeoJson"]; });

/* harmony import */ var _lib_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/transform */ "../gis/src/lib/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transformBinaryCoords", function() { return _lib_transform__WEBPACK_IMPORTED_MODULE_2__["transformBinaryCoords"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transformGeoJsonCoords", function() { return _lib_transform__WEBPACK_IMPORTED_MODULE_2__["transformGeoJsonCoords"]; });






/***/ }),

/***/ "../gis/src/lib/binary-to-geojson.js":
/*!*******************************************!*\
  !*** ../gis/src/lib/binary-to-geojson.js ***!
  \*******************************************/
/*! exports provided: binaryToGeoJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binaryToGeoJson", function() { return binaryToGeoJson; });
function binaryToGeoJson(data, type, format) {
  if (format === 'geometry') {
    return parseGeometry(data);
  }

  const dataArray = normalizeInput(data, type);

  switch (deduceReturnType(dataArray)) {
    case 'Geometry':
      return parseGeometry(dataArray[0]);
    case 'FeatureCollection':
      return parseFeatureCollection(dataArray);
    default:
      break;
  }

  return null;
}

// Normalize features
// Return an array of data objects, each of which have a type key
function normalizeInput(data, type) {
  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);

  if (!isHeterogeneousType) {
    data.type = type || parseType(data);
    return [data];
  }

  const features = [];
  if (data.points) {
    data.points.type = 'Point';
    features.push(data.points);
  }
  if (data.lines) {
    data.lines.type = 'LineString';
    features.push(data.lines);
  }
  if (data.polygons) {
    data.polygons.type = 'Polygon';
    features.push(data.polygons);
  }
  return features;
}

// Determine whether a geometry or feature collection should be returned
// If the input data doesn't have property identifiers, returns a single geometry
function deduceReturnType(dataArray) {
  // If more than one item in dataArray, multiple geometry types, must be a featurecollection
  if (dataArray.length > 1) {
    return 'FeatureCollection';
  }

  const data = dataArray[0];
  if (!(data.featureIds || data.globalFeatureIds || data.numericProps || data.properties)) {
    return 'Geometry';
  }

  return 'FeatureCollection';
}

/** Parse input binary data and return an array of GeoJSON Features */
function parseFeatureCollection(dataArray) {
  const features = [];
  for (const data of dataArray) {
    if (data.featureIds.value.length === 0) {
      // eslint-disable-next-line no-continue
      continue;
    }
    let lastIndex = 0;
    let lastValue = data.featureIds.value[0];

    // Need to deduce start, end indices of each feature
    for (let i = 0; i < data.featureIds.value.length; i++) {
      const currValue = data.featureIds.value[i];
      if (currValue === lastValue) {
        // eslint-disable-next-line no-continue
        continue;
      }

      features.push(parseFeature(data, lastIndex, i));
      lastIndex = i;
      lastValue = currValue;
    }

    // Last feature
    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
  }
  return features;
}

/** Parse input binary data and return a single GeoJSON Feature */
function parseFeature(data, startIndex, endIndex) {
  const geometry = parseGeometry(data, startIndex, endIndex);
  const properties = parseProperties(data, startIndex, endIndex);
  return {type: 'Feature', geometry, properties};
}

/** Parse input binary data and return an object of properties */
function parseProperties(data, startIndex, endIndex) {
  const properties = Object.assign(data.properties[data.featureIds.value[startIndex]]);
  for (const key in data.numericProps) {
    properties[key] = data.numericProps[key].value[startIndex];
  }
  return properties;
}

/** Parse input binary data and return a valid GeoJSON geometry object */
function parseGeometry(data, startIndex, endIndex) {
  switch (data.type) {
    case 'Point':
      return pointToGeoJson(data, startIndex, endIndex);
    case 'LineString':
      return lineStringToGeoJson(data, startIndex, endIndex);
    case 'Polygon':
      return polygonToGeoJson(data, startIndex, endIndex);
    default:
      throw new Error(`Unsupported geometry type: ${data.type}`);
  }
}

/** Parse binary data of type Polygon */
function polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
  const {positions} = data;
  const polygonIndices = data.polygonIndices.value.filter(x => x >= startIndex && x <= endIndex);
  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(
    x => x >= startIndex && x <= endIndex
  );
  const multi = polygonIndices.length > 2;

  const coordinates = [];
  // Polygon
  if (!multi) {
    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {
      const startRingIndex = primitivePolygonIndices[i];
      const endRingIndex = primitivePolygonIndices[i + 1];
      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
      coordinates.push(ringCoordinates);
    }

    return {type: 'Polygon', coordinates};
  }

  // MultiPolygon
  for (let i = 0; i < polygonIndices.length - 1; i++) {
    const startPolygonIndex = polygonIndices[i];
    const endPolygonIndex = polygonIndices[i + 1];
    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex)
      .coordinates;
    coordinates.push(polygonCoordinates);
  }

  return {type: 'MultiPolygon', coordinates};
}

/** Parse binary data of type LineString */
function lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
  const {positions} = data;
  const pathIndices = data.pathIndices.value.filter(x => x >= startIndex && x <= endIndex);
  const multi = pathIndices.length > 2;

  if (!multi) {
    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
    return {type: 'LineString', coordinates};
  }

  const coordinates = [];
  for (let i = 0; i < pathIndices.length - 1; i++) {
    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);
    coordinates.push(ringCoordinates);
  }

  return {type: 'MultiLineString', coordinates};
}

/** Parse binary data of type Point */
function pointToGeoJson(data, startIndex, endIndex) {
  const {positions} = data;
  const coordinates = ringToGeoJson(positions, startIndex, endIndex);
  const multi = coordinates.length > 1;

  if (multi) {
    return {type: 'MultiPoint', coordinates};
  }

  return {type: 'Point', coordinates: coordinates[0]};
}

/**
 * Parse a linear ring of positions to a GeoJSON linear ring
 *
 * @param positions Positions TypedArray
 * @param  {number?} startIndex Start index to include in ring
 * @param  {number?} endIndex End index to include in ring
 * @return {number[][]} GeoJSON ring
 */
function ringToGeoJson(positions, startIndex, endIndex) {
  startIndex = startIndex || 0;
  endIndex = endIndex || positions.value.length / positions.size;

  const ringCoordinates = [];
  for (let j = startIndex; j < endIndex; j++) {
    ringCoordinates.push(
      Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size))
    );
  }
  return ringCoordinates;
}

// Deduce geometry type of data object
function parseType(data) {
  if (data.pathIndices) {
    return 'LineString';
  }

  if (data.polygonIndices) {
    return 'Polygon';
  }

  return 'Point';
}


/***/ }),

/***/ "../gis/src/lib/geojson-to-binary.js":
/*!*******************************************!*\
  !*** ../gis/src/lib/geojson-to-binary.js ***!
  \*******************************************/
/*! exports provided: geojsonToBinary, TEST_EXPORTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geojsonToBinary", function() { return geojsonToBinary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEST_EXPORTS", function() { return TEST_EXPORTS; });
// Convert GeoJSON features to flat binary arrays
// @ts-nocheck

function geojsonToBinary(features, options = {}) {
  const firstPassData = firstPass(features);
  return secondPass(features, firstPassData, {
    coordLength: options.coordLength || firstPassData.coordLength || 2,
    numericPropKeys: options.numericPropKeys || firstPassData.numericPropKeys,
    PositionDataType: options.PositionDataType || Float32Array
  });
}

const TEST_EXPORTS = {
  firstPass,
  secondPass
};

// Initial scan over GeoJSON features
// Counts number of coordinates of each geometry type and keeps track of the max coordinate
// dimensions
// eslint-disable-next-line complexity, max-statements
function firstPass(features) {
  // Counts the number of _positions_, so [x, y, z] counts as one
  let pointPositionsCount = 0;
  let pointFeaturesCount = 0;
  let linePositionsCount = 0;
  let linePathsCount = 0;
  let lineFeaturesCount = 0;
  let polygonPositionsCount = 0;
  let polygonObjectsCount = 0;
  let polygonRingsCount = 0;
  let polygonFeaturesCount = 0;
  const coordLengths = new Set();
  const numericPropKeys = {};

  for (const feature of features) {
    const geometry = feature.geometry;
    switch (geometry.type) {
      case 'Point':
        pointFeaturesCount++;
        pointPositionsCount++;
        coordLengths.add(geometry.coordinates.length);
        break;
      case 'MultiPoint':
        pointFeaturesCount++;
        pointPositionsCount += geometry.coordinates.length;
        for (const point of geometry.coordinates) {
          coordLengths.add(point.length);
        }
        break;
      case 'LineString':
        lineFeaturesCount++;
        linePositionsCount += geometry.coordinates.length;
        linePathsCount++;

        for (const coord of geometry.coordinates) {
          coordLengths.add(coord.length);
        }
        break;
      case 'MultiLineString':
        lineFeaturesCount++;
        for (const line of geometry.coordinates) {
          linePositionsCount += line.length;
          linePathsCount++;

          // eslint-disable-next-line max-depth
          for (const coord of line) {
            coordLengths.add(coord.length);
          }
        }
        break;
      case 'Polygon':
        polygonFeaturesCount++;
        polygonObjectsCount++;
        polygonRingsCount += geometry.coordinates.length;
        polygonPositionsCount += flatten(geometry.coordinates).length;

        for (const coord of flatten(geometry.coordinates)) {
          coordLengths.add(coord.length);
        }
        break;
      case 'MultiPolygon':
        polygonFeaturesCount++;
        for (const polygon of geometry.coordinates) {
          polygonObjectsCount++;
          polygonRingsCount += polygon.length;
          polygonPositionsCount += flatten(polygon).length;

          // eslint-disable-next-line max-depth
          for (const coord of flatten(polygon)) {
            coordLengths.add(coord.length);
          }
        }
        break;
      default:
        throw new Error(`Unsupported geometry type: ${geometry.type}`);
    }

    if (feature.properties) {
      for (const key in feature.properties) {
        const val = feature.properties[key];

        // If property has not been seen before, or if property has been numeric
        // in all previous features, check if numeric in this feature
        // If not numeric, false is stored to prevent rechecking in the future
        numericPropKeys[key] =
          numericPropKeys[key] || numericPropKeys[key] === undefined
            ? isNumeric(val)
            : numericPropKeys[key];
      }
    }
  }

  return {
    pointPositionsCount,
    pointFeaturesCount,
    linePositionsCount,
    linePathsCount,
    lineFeaturesCount,
    coordLength: coordLengths.size > 0 && Math.max(...coordLengths),
    polygonPositionsCount,
    polygonObjectsCount,
    polygonRingsCount,
    polygonFeaturesCount,
    // Array of keys whose values are always numeric
    numericPropKeys: Object.keys(numericPropKeys).filter(k => numericPropKeys[k])
  };
}

// Second scan over GeoJSON features
// Fills coordinates into pre-allocated typed arrays
// eslint-disable-next-line complexity
function secondPass(features, firstPassData = {}, options = {}) {
  const {
    pointPositionsCount,
    pointFeaturesCount,
    linePositionsCount,
    linePathsCount,
    lineFeaturesCount,
    polygonPositionsCount,
    polygonObjectsCount,
    polygonRingsCount,
    polygonFeaturesCount
  } = firstPassData;
  const {coordLength, numericPropKeys, PositionDataType = Float32Array} = options;
  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
  const points = {
    positions: new PositionDataType(pointPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
    featureIds:
      pointFeaturesCount > 65535
        ? new Uint32Array(pointPositionsCount)
        : new Uint16Array(pointPositionsCount),
    numericProps: {},
    properties: []
  };
  const lines = {
    pathIndices:
      linePositionsCount > 65535
        ? new Uint32Array(linePathsCount + 1)
        : new Uint16Array(linePathsCount + 1),
    positions: new PositionDataType(linePositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
    featureIds:
      lineFeaturesCount > 65535
        ? new Uint32Array(linePositionsCount)
        : new Uint16Array(linePositionsCount),
    numericProps: {},
    properties: []
  };
  const polygons = {
    polygonIndices:
      polygonPositionsCount > 65535
        ? new Uint32Array(polygonObjectsCount + 1)
        : new Uint16Array(polygonObjectsCount + 1),
    primitivePolygonIndices:
      polygonPositionsCount > 65535
        ? new Uint32Array(polygonRingsCount + 1)
        : new Uint16Array(polygonRingsCount + 1),
    positions: new PositionDataType(polygonPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
    featureIds:
      polygonFeaturesCount > 65535
        ? new Uint32Array(polygonPositionsCount)
        : new Uint16Array(polygonPositionsCount),
    numericProps: {},
    properties: []
  };

  // Instantiate numeric properties arrays; one value per vertex
  for (const object of [points, lines, polygons]) {
    for (const propName of numericPropKeys) {
      // If property has been numeric in all previous features in which the property existed, check
      // if numeric in this feature
      object.numericProps[propName] = new Float32Array(object.positions.length / coordLength);
    }
  }

  // Set last element of path/polygon indices as positions length
  lines.pathIndices[linePathsCount] = linePositionsCount;
  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;

  const indexMap = {
    pointPosition: 0,
    pointFeature: 0,
    linePosition: 0,
    linePath: 0,
    lineFeature: 0,
    polygonPosition: 0,
    polygonObject: 0,
    polygonRing: 0,
    polygonFeature: 0,
    feature: 0
  };

  for (const feature of features) {
    const geometry = feature.geometry;
    const properties = feature.properties || {};

    switch (geometry.type) {
      case 'Point':
        handlePoint(geometry.coordinates, points, indexMap, coordLength, properties);
        points.properties.push(keepStringProperties(properties, numericPropKeys));
        indexMap.pointFeature++;
        break;
      case 'MultiPoint':
        handleMultiPoint(geometry.coordinates, points, indexMap, coordLength, properties);
        points.properties.push(keepStringProperties(properties, numericPropKeys));
        indexMap.pointFeature++;
        break;
      case 'LineString':
        handleLineString(geometry.coordinates, lines, indexMap, coordLength, properties);
        lines.properties.push(keepStringProperties(properties, numericPropKeys));
        indexMap.lineFeature++;
        break;
      case 'MultiLineString':
        handleMultiLineString(geometry.coordinates, lines, indexMap, coordLength, properties);
        lines.properties.push(keepStringProperties(properties, numericPropKeys));
        indexMap.lineFeature++;
        break;
      case 'Polygon':
        handlePolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);
        polygons.properties.push(keepStringProperties(properties, numericPropKeys));
        indexMap.polygonFeature++;
        break;
      case 'MultiPolygon':
        handleMultiPolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);
        polygons.properties.push(keepStringProperties(properties, numericPropKeys));
        indexMap.polygonFeature++;
        break;
      default:
        throw new Error('Invalid geometry type');
    }

    indexMap.feature++;
  }

  // Wrap each array in an accessor object with value and size keys
  return makeAccessorObjects(points, lines, polygons, coordLength);
}

// Fills Point coordinates into points object of arrays
function handlePoint(coords, points, indexMap, coordLength, properties) {
  points.positions.set(coords, indexMap.pointPosition * coordLength);
  points.globalFeatureIds[indexMap.pointPosition] = indexMap.feature;
  points.featureIds[indexMap.pointPosition] = indexMap.pointFeature;

  fillNumericProperties(points, properties, indexMap.pointPosition, 1);
  indexMap.pointPosition++;
}

// Fills MultiPoint coordinates into points object of arrays
function handleMultiPoint(coords, points, indexMap, coordLength, properties) {
  for (const point of coords) {
    handlePoint(point, points, indexMap, coordLength, properties);
  }
}

// Fills LineString coordinates into lines object of arrays
function handleLineString(coords, lines, indexMap, coordLength, properties) {
  lines.pathIndices[indexMap.linePath] = indexMap.linePosition;
  indexMap.linePath++;

  fillCoords(lines.positions, coords, indexMap.linePosition, coordLength);

  const nPositions = coords.length;
  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);

  lines.globalFeatureIds.set(
    new Uint32Array(nPositions).fill(indexMap.feature),
    indexMap.linePosition
  );
  lines.featureIds.set(
    new Uint32Array(nPositions).fill(indexMap.lineFeature),
    indexMap.linePosition
  );
  indexMap.linePosition += nPositions;
}

// Fills MultiLineString coordinates into lines object of arrays
function handleMultiLineString(coords, lines, indexMap, coordLength, properties) {
  for (const line of coords) {
    handleLineString(line, lines, indexMap, coordLength, properties);
  }
}

// Fills Polygon coordinates into polygons object of arrays
function handlePolygon(coords, polygons, indexMap, coordLength, properties) {
  polygons.polygonIndices[indexMap.polygonObject] = indexMap.polygonPosition;
  indexMap.polygonObject++;

  for (const ring of coords) {
    polygons.primitivePolygonIndices[indexMap.polygonRing] = indexMap.polygonPosition;
    indexMap.polygonRing++;

    fillCoords(polygons.positions, ring, indexMap.polygonPosition, coordLength);

    const nPositions = ring.length;
    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);

    polygons.globalFeatureIds.set(
      new Uint32Array(nPositions).fill(indexMap.feature),
      indexMap.polygonPosition
    );
    polygons.featureIds.set(
      new Uint32Array(nPositions).fill(indexMap.polygonFeature),
      indexMap.polygonPosition
    );
    indexMap.polygonPosition += nPositions;
  }
}

// Fills MultiPolygon coordinates into polygons object of arrays
function handleMultiPolygon(coords, polygons, indexMap, coordLength, properties) {
  for (const polygon of coords) {
    handlePolygon(polygon, polygons, indexMap, coordLength, properties);
  }
}

// Wrap each array in an accessor object with value and size keys
function makeAccessorObjects(points, lines, polygons, coordLength) {
  const returnObj = {
    points: {
      positions: {value: points.positions, size: coordLength},
      globalFeatureIds: {value: points.globalFeatureIds, size: 1},
      featureIds: {value: points.featureIds, size: 1},
      numericProps: points.numericProps,
      properties: points.properties
    },
    lines: {
      pathIndices: {value: lines.pathIndices, size: 1},
      positions: {value: lines.positions, size: coordLength},
      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},
      featureIds: {value: lines.featureIds, size: 1},
      numericProps: lines.numericProps,
      properties: lines.properties
    },
    polygons: {
      polygonIndices: {value: polygons.polygonIndices, size: 1},
      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},
      positions: {value: polygons.positions, size: coordLength},
      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},
      featureIds: {value: polygons.featureIds, size: 1},
      numericProps: polygons.numericProps,
      properties: polygons.properties
    }
  };

  for (const geomType in returnObj) {
    for (const numericProp in returnObj[geomType].numericProps) {
      returnObj[geomType].numericProps[numericProp] = {
        value: returnObj[geomType].numericProps[numericProp],
        size: 1
      };
    }
  }
  return returnObj;
}

// Add numeric properties to object
function fillNumericProperties(object, properties, index, length) {
  for (const numericPropName in object.numericProps) {
    if (numericPropName in properties) {
      object.numericProps[numericPropName].set(
        new Array(length).fill(properties[numericPropName]),
        index
      );
    }
  }
}

// Keep string properties in object
function keepStringProperties(properties, numericKeys) {
  const props = {};
  for (const key in properties) {
    if (!numericKeys.includes(key)) {
      props[key] = properties[key];
    }
  }
  return props;
}

// coords is expected to be a list of arrays, each with length 2-3
function fillCoords(array, coords, startVertex, coordLength) {
  let index = startVertex * coordLength;
  for (const coord of coords) {
    array.set(coord, index);
    index += coordLength;
  }
}

function flatten(arrays) {
  return [].concat(...arrays);
}

function isNumeric(x) {
  return Number.isFinite(x);
}


/***/ }),

/***/ "../gis/src/lib/transform.js":
/*!***********************************!*\
  !*** ../gis/src/lib/transform.js ***!
  \***********************************/
/*! exports provided: transformBinaryCoords, transformGeoJsonCoords */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformBinaryCoords", function() { return transformBinaryCoords; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformGeoJsonCoords", function() { return transformGeoJsonCoords; });
/**
 * Apply transformation to every coordinate of binary features
 *
 * @param  binaryFeatures binary features
 * @param  fn       Function to call on each coordinate
 * @return          Transformed binary features
 */
function transformBinaryCoords(binaryFeatures, fn) {
  // Expect binaryFeatures to have points, lines, and polygons keys
  for (const binaryFeature of Object.values(binaryFeatures)) {
    const {positions} = binaryFeature;
    for (let i = 0; i < positions.value.length; i += positions.size) {
      const coord = Array.from(positions.value.subarray(i, i + positions.size));
      const transformedCoord = fn(coord);
      positions.value.set(transformedCoord, i);
    }
  }
  return binaryFeatures;
}

/**
 * Apply transformation to every coordinate of GeoJSON features
 *
 * @param  features Array of GeoJSON features
 * @param  fn       Function to call on each coordinate
 * @return          Transformed GeoJSON features
 */
function transformGeoJsonCoords(features, fn) {
  for (const feature of features) {
    feature.geometry.coordinates = coordMap(feature.geometry.coordinates, fn);
  }
  return features;
}

function coordMap(array, fn) {
  if (isCoord(array)) {
    return fn(array);
  }

  return array.map(item => {
    return coordMap(item, fn);
  });
}

function isCoord(array) {
  return Number.isFinite(array[0]) && Number.isFinite(array[1]);
}


/***/ }),

/***/ "../loader-utils/src/categories/mesh/mesh-utils.js":
/*!*********************************************************!*\
  !*** ../loader-utils/src/categories/mesh/mesh-utils.js ***!
  \*********************************************************/
/*! exports provided: getMeshSize, getMeshBoundingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshSize", function() { return getMeshSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshBoundingBox", function() { return getMeshBoundingBox; });
function getMeshSize(attributes) {
  let size = 0;
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    if (ArrayBuffer.isView(attribute)) {
      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT
      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;
    }
  }
  return size;
}

// eslint-disable-next-line complexity
function getMeshBoundingBox(attributes) {
  if (!attributes || !attributes.POSITION) {
    return null;
  }

  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;

  const positions = attributes.POSITION.value;
  const len = positions && positions.length;

  if (!len) {
    return null;
  }

  for (let i = 0; i < len; i += 3) {
    const x = positions[i];
    const y = positions[i + 1];
    const z = positions[i + 2];

    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;

    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }
  return [[minX, minY, minZ], [maxX, maxY, maxZ]];
}


/***/ }),

/***/ "../loader-utils/src/index.js":
/*!************************************!*\
  !*** ../loader-utils/src/index.js ***!
  \************************************/
/*! exports provided: assert, isBrowser, isWorker, nodeVersion, self, window, global, document, createWorker, validateLoaderVersion, makeTransformIterator, getTransferList, _WorkerFarm, _WorkerPool, _WorkerThread, getLibraryUrl, loadLibrary, parseJSON, isBuffer, toBuffer, bufferToArrayBuffer, toArrayBuffer, sliceArrayBuffer, concatenateArrayBuffers, compareArrayBuffers, padTo4Bytes, copyToArray, copyArrayBuffer, copyPaddedArrayBufferToDataView, copyPaddedStringToDataView, padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView, getFirstCharacters, getMagicString, path, setPathPrefix, getPathPrefix, resolvePath, _addAliases, makeTextEncoderIterator, makeTextDecoderIterator, makeLineIterator, makeNumberedLineIterator, forEach, concatenateChunksAsync, RequestScheduler, ChildProcessProxy, _getMeshSize, getMeshBoundingBox, getZeroOffsetArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/env-utils/globals */ "../loader-utils/src/lib/env-utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["isWorker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["nodeVersion"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["document"]; });

/* harmony import */ var _lib_worker_loader_utils_create_worker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/worker-loader-utils/create-worker */ "../loader-utils/src/lib/worker-loader-utils/create-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createWorker", function() { return _lib_worker_loader_utils_create_worker__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _lib_worker_loader_utils_validate_loader_version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/worker-loader-utils/validate-loader-version */ "../loader-utils/src/lib/worker-loader-utils/validate-loader-version.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateLoaderVersion", function() { return _lib_worker_loader_utils_validate_loader_version__WEBPACK_IMPORTED_MODULE_3__["validateLoaderVersion"]; });

/* harmony import */ var _lib_iterator_utils_make_transform_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/iterator-utils/make-transform-iterator */ "../loader-utils/src/lib/iterator-utils/make-transform-iterator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeTransformIterator", function() { return _lib_iterator_utils_make_transform_iterator__WEBPACK_IMPORTED_MODULE_4__["makeTransformIterator"]; });

/* harmony import */ var _lib_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/worker-utils/get-transfer-list */ "../loader-utils/src/lib/worker-utils/get-transfer-list.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return _lib_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_5__["getTransferList"]; });

/* harmony import */ var _lib_worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/worker-utils/worker-farm */ "../loader-utils/src/lib/worker-utils/worker-farm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerFarm", function() { return _lib_worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _lib_worker_utils_worker_pool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/worker-utils/worker-pool */ "../loader-utils/src/lib/worker-utils/worker-pool.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerPool", function() { return _lib_worker_utils_worker_pool__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _lib_worker_utils_worker_thread__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/worker-utils/worker-thread */ "../loader-utils/src/lib/worker-utils/worker-thread.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerThread", function() { return _lib_worker_utils_worker_thread__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/library-utils/library-utils */ "../loader-utils/src/lib/library-utils/library-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getLibraryUrl", function() { return _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_9__["getLibraryUrl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadLibrary", function() { return _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_9__["loadLibrary"]; });

/* harmony import */ var _lib_parser_utils_parse_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/parser-utils/parse-json */ "../loader-utils/src/lib/parser-utils/parse-json.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseJSON", function() { return _lib_parser_utils_parse_json__WEBPACK_IMPORTED_MODULE_10__["parseJSON"]; });

/* harmony import */ var _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/binary-utils/buffer-utils */ "../loader-utils/src/lib/binary-utils/buffer-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBuffer", function() { return _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_11__["isBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toBuffer", function() { return _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_11__["toBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferToArrayBuffer", function() { return _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_11__["bufferToArrayBuffer"]; });

/* harmony import */ var _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/binary-utils/array-buffer-utils */ "../loader-utils/src/lib/binary-utils/array-buffer-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__["toArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sliceArrayBuffer", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__["sliceArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__["concatenateArrayBuffers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compareArrayBuffers", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__["compareArrayBuffers"]; });

/* harmony import */ var _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/binary-utils/memory-copy-utils */ "../loader-utils/src/lib/binary-utils/memory-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__["padTo4Bytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__["copyToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__["copyArrayBuffer"]; });

/* harmony import */ var _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/binary-utils/binary-copy-utils */ "../loader-utils/src/lib/binary-utils/binary-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_14__["copyPaddedArrayBufferToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_14__["copyPaddedStringToDataView"]; });

/* harmony import */ var _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/binary-utils/encode-utils */ "../loader-utils/src/lib/binary-utils/encode-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_15__["padStringToByteAlignment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_15__["copyStringToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_15__["copyBinaryToDataView"]; });

/* harmony import */ var _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/binary-utils/get-first-characters */ "../loader-utils/src/lib/binary-utils/get-first-characters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFirstCharacters", function() { return _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_16__["getFirstCharacters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMagicString", function() { return _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_16__["getMagicString"]; });

/* harmony import */ var _lib_path_utils_path__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/path-utils/path */ "../loader-utils/src/lib/path-utils/path.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _lib_path_utils_path__WEBPACK_IMPORTED_MODULE_17__; });
/* harmony import */ var _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/path-utils/file-aliases */ "../loader-utils/src/lib/path-utils/file-aliases.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__["getPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__["resolvePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_addAliases", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__["addAliases"]; });

/* harmony import */ var _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lib/iterator-utils/text-iterators */ "../loader-utils/src/lib/iterator-utils/text-iterators.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeTextEncoderIterator", function() { return _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__["makeTextEncoderIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeTextDecoderIterator", function() { return _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__["makeTextDecoderIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeLineIterator", function() { return _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__["makeLineIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeNumberedLineIterator", function() { return _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__["makeNumberedLineIterator"]; });

/* harmony import */ var _lib_iterator_utils_async_iteration__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/iterator-utils/async-iteration */ "../loader-utils/src/lib/iterator-utils/async-iteration.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _lib_iterator_utils_async_iteration__WEBPACK_IMPORTED_MODULE_20__["forEach"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateChunksAsync", function() { return _lib_iterator_utils_async_iteration__WEBPACK_IMPORTED_MODULE_20__["concatenateChunksAsync"]; });

/* harmony import */ var _lib_request_utils_request_scheduler__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lib/request-utils/request-scheduler */ "../loader-utils/src/lib/request-utils/request-scheduler.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RequestScheduler", function() { return _lib_request_utils_request_scheduler__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _lib_process_utils_child_process_proxy__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/process-utils/child-process-proxy */ "../loader-utils/src/lib/process-utils/child-process-proxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ChildProcessProxy", function() { return _lib_process_utils_child_process_proxy__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./categories/mesh/mesh-utils */ "../loader-utils/src/categories/mesh/mesh-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getMeshSize", function() { return _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_23__["getMeshSize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMeshBoundingBox", function() { return _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_23__["getMeshBoundingBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getZeroOffsetArrayBuffer", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__["getZeroOffsetArrayBuffer"]; });

// GENERAL UTILS



// WORKER LOADER UTILS




// WORKER UTILS





// LIBRARY UTILS


// PARSER UTILS


// MEMORY COPY UTILS







// PATH UTILS






// ITERATOR UTILS




// REQUEST UTILS


// PROCESS UTILS


// MESH CATEGORY UTILS
// Note: Should move to category specific module if code size increases


// DEPRECATED IN 2.3



/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/array-buffer-utils.js":
/*!******************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/array-buffer-utils.js ***!
  \******************************************************************/
/*! exports provided: toArrayBuffer, compareArrayBuffers, concatenateArrayBuffers, sliceArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return toArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareArrayBuffers", function() { return compareArrayBuffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return concatenateArrayBuffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sliceArrayBuffer", function() { return sliceArrayBuffer; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/buffer-utils.node */ 1);
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__);
/** @typedef {import('./array-buffer-utils')} types */
/* global TextEncoder */



/** @type {types['toArrayBuffer']} */
function toArrayBuffer(data) {
  // Note: Should be called first, Buffers can trigger other detections below
  if (_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__["toArrayBuffer"]) {
    // TODO - per docs we should just be able to call buffer.buffer, but there are issues
    data = _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__["toArrayBuffer"](data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  // HACK to support Blob polyfill
  if (data && typeof data === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }

  return Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}

/** @type {types['compareArrayBuffers']} */
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}

// Concatenate ArrayBuffers
/** @type {types['concatenateArrayBuffers']} */
function concatenateArrayBuffers(...sources) {
  // Make sure all inputs are wrapped in typed arrays
  const sourceArrays = sources.map(
    source2 => (source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2)
  );

  // Get length of all inputs
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);

  // Allocate array with space for all inputs
  const result = new Uint8Array(byteLength);

  // Copy the subarrays
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }

  // We work with ArrayBuffers, discard the typed array wrapper
  return result.buffer;
}

// Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray =
    byteLength !== undefined
      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)
      : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/binary-copy-utils.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/binary-copy-utils.js ***!
  \*****************************************************************/
/*! exports provided: copyPaddedArrayBufferToDataView, copyPaddedStringToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return copyPaddedArrayBufferToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return copyPaddedStringToDataView; });
/* harmony import */ var _memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory-copy-utils */ "../loader-utils/src/lib/binary-utils/memory-copy-utils.js");
/* global TextEncoder */


function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer) {
  const paddedLength = Object(_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(sourceBuffer.byteLength);
  const padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    // Copy array
    const targetArray = new Uint8Array(
      dataView.buffer,
      dataView.byteOffset + byteOffset,
      sourceBuffer.byteLength
    );
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    // Add PADDING
    for (let i = 0; i < padLength; ++i) {
      // json chunk is padded with spaces (ASCII 0x20)
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }
  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string) {
  const textEncoder = new TextEncoder();
  // PERFORMANCE IDEA: We encode twice, once to get size and once to store
  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy
  const stringBuffer = textEncoder.encode(string);

  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer);

  return byteOffset;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/buffer-utils.js":
/*!************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/buffer-utils.js ***!
  \************************************************************/
/*! exports provided: isBuffer, toBuffer, bufferToArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBuffer", function() { return isBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toBuffer", function() { return toBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToArrayBuffer", function() { return bufferToArrayBuffer; });
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/buffer-utils.node */ 1);
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__);
/** @typedef {import('./buffer-utils')} types */


/** @type {types['isBuffer']} */
function isBuffer(x) {
  return x && typeof x === 'object' && x.isBuffer;
}

/** @type {types['toBuffer']} */
function toBuffer(data) {
  return _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toBuffer"] ? _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toBuffer"](data) : data;
}

/** @type {types['bufferToArrayBuffer']} */
function bufferToArrayBuffer(data) {
  if (_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"]) {
    // TODO - per docs we should just be able to call buffer.buffer, but there are issues
    return _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"](data);
  }
  return data;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/encode-utils.js":
/*!************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/encode-utils.js ***!
  \************************************************************/
/*! exports provided: padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return padStringToByteAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return copyStringToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return copyBinaryToDataView; });
// UTILITIES

// PERFORMANCE IDEA: No need to copy string twice...
function padStringToByteAlignment(string, byteAlignment) {
  const length = string.length;
  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment
  const padding = paddedLength - length;
  let whitespace = '';
  for (let i = 0; i < padding; ++i) {
    whitespace += ' ';
  }
  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }
  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
      byteOffset++;
    }
  }
  return byteOffset + byteLength;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/get-first-characters.js":
/*!********************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/get-first-characters.js ***!
  \********************************************************************/
/*! exports provided: getFirstCharacters, getMagicString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFirstCharacters", function() { return getFirstCharacters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMagicString", function() { return getMagicString; });
function getFirstCharacters(data, length = 5) {
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    // Typed Arrays can have offsets into underlying buffer
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/memory-copy-utils.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/memory-copy-utils.js ***!
  \*****************************************************************/
/*! exports provided: padTo4Bytes, getZeroOffsetArrayBuffer, copyArrayBuffer, copyToArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return padTo4Bytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getZeroOffsetArrayBuffer", function() { return getZeroOffsetArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return copyArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return copyToArray; });
/* harmony import */ var _array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array-buffer-utils */ "../loader-utils/src/lib/binary-utils/array-buffer-utils.js");


function padTo4Bytes(byteLength) {
  return (byteLength + 3) & ~3;
}

function getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  return Object(_array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__["sliceArrayBuffer"])(arrayBuffer, byteOffset, byteLength);
}

/* Creates a new Uint8Array based on two different ArrayBuffers
 * @private
 * @param {ArrayBuffers} buffer1 The first buffer.
 * @param {ArrayBuffers} buffer2 The second buffer.
 * @return {ArrayBuffers} The new ArrayBuffer created out of the two.
 */
function copyArrayBuffer(
  targetBuffer,
  sourceBuffer,
  byteOffset,
  byteLength = sourceBuffer.byteLength
) {
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

/**
 * Copy from source to target at the targetOffset
 *
 * @param {ArrayBuffer|any} source - The data to copy
 * @param {any} target - The destination to copy data into
 * @param {Number} targetOffset - The start offset into target to place the copied data
 *
 * @return {Number} Returns the new offset taking into account proper padding
 */
function copyToArray(source, target, targetOffset) {
  let sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    // Pack buffer onto the big target array
    //
    // 'source.data.buffer' could be a view onto a larger buffer.
    // We MUST use this constructor to ensure the byteOffset and byteLength is
    // set to correct values from 'source.data' and not the underlying
    // buffer for target.set() to work properly.
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);
  }

  // Pack buffer onto the big target array
  target.set(sourceArray, targetOffset);

  return targetOffset + padTo4Bytes(sourceArray.byteLength);
}


/***/ }),

/***/ "../loader-utils/src/lib/env-utils/assert.js":
/*!***************************************************!*\
  !*** ../loader-utils/src/lib/env-utils/assert.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/env-utils/globals.js":
/*!****************************************************!*\
  !*** ../loader-utils/src/lib/env-utils/globals.js ***!
  \****************************************************/
/*! exports provided: self, window, global, document, isBrowser, isWorker, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return isWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

// @ts-nocheck
/* eslint-disable no-restricted-globals */
/* global process, window, global, document, self, importScripts */
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};

const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};



const isBrowser =
  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;

const isWorker = typeof importScripts === 'function';

// Extract node major version
const matches =
  typeof process !== 'undefined' && process.version && process.version.match(/v([0-9]*)/);
const nodeVersion = (matches && parseFloat(matches[1])) || 0;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../loader-utils/src/lib/iterator-utils/async-iteration.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/iterator-utils/async-iteration.js ***!
  \*****************************************************************/
/*! exports provided: forEach, concatenateChunksAsync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateChunksAsync", function() { return concatenateChunksAsync; });
/* harmony import */ var _binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary-utils/array-buffer-utils */ "../loader-utils/src/lib/binary-utils/array-buffer-utils.js");
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");



// GENERAL UTILITIES

/**
 * Iterate over async iterator, without resetting iterator if end is not reached
 * - forEach intentionally does not reset iterator if exiting loop prematurely
 *   so that iteration can continue in a second loop
 * - It is recommended to use a standard for-await as last loop to ensure
 *   iterator gets properly reset
 *
 * TODO - optimize using sync iteration if argument is an Iterable?
 *
 * @param iterator
 * @param visitor
 */
async function forEach(iterator, visitor) {
  // eslint-disable-next-line
  while (true) {
    const {done, value} = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}

// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects

/**
 * Concatenates all data chunks yielded by an (async) iterator
 * Supports strings and ArrayBuffers
 *
 * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs
 */
async function concatenateChunksAsync(asyncIterator) {
  /** @type {ArrayBuffer[]} */
  const arrayBuffers = [];
  /** @type {string[]} */
  const strings = [];
  for await (const chunk of asyncIterator) {
    if (typeof chunk === 'string') {
      strings.push(chunk);
    } else {
      arrayBuffers.push(chunk);
    }
  }

  if (strings.length > 0) {
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(arrayBuffers.length === 0);
    return strings.join('');
  }

  return Object(_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__["concatenateArrayBuffers"])(...arrayBuffers);
}


/***/ }),

/***/ "../loader-utils/src/lib/iterator-utils/make-transform-iterator.js":
/*!*************************************************************************!*\
  !*** ../loader-utils/src/lib/iterator-utils/make-transform-iterator.js ***!
  \*************************************************************************/
/*! exports provided: makeTransformIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTransformIterator", function() { return makeTransformIterator; });
async function* makeTransformIterator(asyncIterator, IncrementalTransform, options) {
  const transform = new IncrementalTransform(options);
  for await (const chunk of asyncIterator) {
    const output = await transform.write(chunk);
    if (output) {
      yield output;
    }
  }
  const output = await transform.end();
  if (output) {
    yield output;
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/iterator-utils/text-iterators.js":
/*!****************************************************************!*\
  !*** ../loader-utils/src/lib/iterator-utils/text-iterators.js ***!
  \****************************************************************/
/*! exports provided: makeTextDecoderIterator, makeTextEncoderIterator, makeLineIterator, makeNumberedLineIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTextDecoderIterator", function() { return makeTextDecoderIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTextEncoderIterator", function() { return makeTextEncoderIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeLineIterator", function() { return makeLineIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeNumberedLineIterator", function() { return makeNumberedLineIterator; });
// TextDecoder iterators
// TextDecoder will keep any partial undecoded bytes between calls to `decode`

/* global TextDecoder, TextEncoder */

async function* makeTextDecoderIterator(arrayBufferIterator, options) {
  const textDecoder = new TextDecoder(options);
  for await (const arrayBuffer of arrayBufferIterator) {
    yield typeof arrayBuffer === 'string'
      ? arrayBuffer
      : textDecoder.decode(arrayBuffer, {stream: true});
  }
}

// TextEncoder iterator
// TODO - this is not useful unless min chunk size is given
// TextEncoder will keep any partial undecoded bytes between calls to `encode`
// If iterator does not yield strings, assume arrayBuffer and return unencoded

async function* makeTextEncoderIterator(textIterator, options) {
  const textEncoder = new TextEncoder();
  for await (const text of textIterator) {
    yield typeof text === 'string' ? textEncoder.encode(text) : text;
  }
}

/**
 * @param textIterator async iterable yielding strings
 * @returns an async iterable over lines
 * See http://2ality.com/2018/04/async-iter-nodejs.html
 */

async function* makeLineIterator(textIterator) {
  let previous = '';
  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;
    while ((eolIndex = previous.indexOf('\n')) >= 0) {
      // line includes the EOL
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }

  if (previous.length > 0) {
    yield previous;
  }
}

/**
 * @param lineIterator async iterable yielding lines
 * @returns async iterable yielding numbered lines
 *
 * See http://2ality.com/2018/04/async-iter-nodejs.html
 */
async function* makeNumberedLineIterator(lineIterator) {
  let counter = 1;
  for await (const line of lineIterator) {
    yield {counter, line};
    counter++;
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/library-utils/library-utils.js":
/*!**************************************************************!*\
  !*** ../loader-utils/src/lib/library-utils/library-utils.js ***!
  \**************************************************************/
/*! exports provided: loadLibrary, getLibraryUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadLibrary", function() { return loadLibrary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLibraryUrl", function() { return getLibraryUrl; });
/* harmony import */ var _env_utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/globals */ "../loader-utils/src/lib/env-utils/globals.js");
/* harmony import */ var _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/require-utils.node */ 0);
/* harmony import */ var _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* global fetch, document */




// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...
const LATEST = 'beta';

// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.13" : undefined;

const loadLibraryPromises = {}; // promises

// Dynamically loads a library ("module")
async function loadLibrary(libraryUrl, moduleName = null, options = {}) {
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }

  // Ensure libraries are only loaded once
  loadLibraryPromises[libraryUrl] =
    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}

// TODO - sort out how to resolve paths for main/worker and dev/prod
function getLibraryUrl(library, moduleName, options) {
  // Allow application to import and supply libraries through `options.modules`
  const modules = options.modules || {};
  if (modules[library]) {
    return modules[library];
  }

  // Load from local files, not from CDN scripts in Node.js
  // TODO - needs to locate the modules directory when installed!
  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return `modules/${moduleName}/dist/libs/${library}`;
  }

  // In browser, load from external scripts
  if (options.CDN) {
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(options.CDN.startsWith('http'));
    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;
  }

  // TODO - loading inside workers requires paths relative to worker script location...
  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    return `../src/libs/${library}`;
  }

  return `modules/${moduleName}/src/libs/${library}`;
}

async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith('wasm')) {
    const response = await fetch(libraryUrl);
    return await response.arrayBuffer();
  }

  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromFile"] && _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromFile"](libraryUrl);
  }
  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    /* global importScripts */
    return importScripts(libraryUrl);
  }
  // TODO - fix - should be more secure than string parsing since observes CORS
  // if (isBrowser) {
  //   return await loadScriptFromFile(libraryUrl);
  // }

  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}

/*
async function loadScriptFromFile(libraryUrl) {
  const script = document.createElement('script');
  script.src = libraryUrl;
  return await new Promise((resolve, reject) => {
    script.onload = data => {
      resolve(data);
    };
    script.onerror = reject;
  });
}
*/

// TODO - Needs security audit...
//  - Raw eval call
//  - Potentially bypasses CORS
// Upside is that this separates fetching and parsing
// we could create a`LibraryLoader` or`ModuleLoader`
function loadLibraryFromString(scriptSource, id) {
  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromString"] && _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromString"](scriptSource, id);
  }

  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    // Use lvalue trick to make eval run in global scope
    eval.call(_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"], scriptSource); // eslint-disable-line no-eval
    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript
    // http://perfectionkills.com/global-eval-what-are-the-options/
    return null;
  }

  const script = document.createElement('script');
  script.id = id;
  // most browsers like a separate text node but some throw an error. The second method covers those.
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}

// TODO - technique for module injection into worker, from THREE.DracoLoader...
/*
function combineWorkerWithLibrary(worker, jsContent) {
  var fn = wWorker.toString();
  var body = [
    '// injected',
    jsContent,
    '',
    '// worker',
    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))
  ].join('\n');
  this.workerSourceURL = URL.createObjectURL(new Blob([body]));
}
*/


/***/ }),

/***/ "../loader-utils/src/lib/parser-utils/parse-json.js":
/*!**********************************************************!*\
  !*** ../loader-utils/src/lib/parser-utils/parse-json.js ***!
  \**********************************************************/
/*! exports provided: parseJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseJSON", function() { return parseJSON; });
/* harmony import */ var _binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary-utils/get-first-characters */ "../loader-utils/src/lib/binary-utils/get-first-characters.js");


// Minimal JSON parser with a meaningful error message
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error(`Failed to parse JSON from data starting with "${Object(_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_0__["getFirstCharacters"])(string)}"`);
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/path-utils/file-aliases.js":
/*!**********************************************************!*\
  !*** ../loader-utils/src/lib/path-utils/file-aliases.js ***!
  \**********************************************************/
/*! exports provided: setPathPrefix, getPathPrefix, addAliases, resolvePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return getPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAliases", function() { return addAliases; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return resolvePath; });
// Simple file alias mechanisms for tests.

let pathPrefix = '';
const fileAliases = {};

/*
 * Set a relative path prefix
 */
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

// Note: addAliases are an experimental export,
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }
  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = `${pathPrefix}${filename}`;
  }
  return filename;
}


/***/ }),

/***/ "../loader-utils/src/lib/path-utils/path.js":
/*!**************************************************!*\
  !*** ../loader-utils/src/lib/path-utils/path.js ***!
  \**************************************************/
/*! exports provided: dirname */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dirname", function() { return dirname; });
// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.
function dirname(url) {
  const slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}


/***/ }),

/***/ "../loader-utils/src/lib/process-utils/child-process-proxy.js":
/*!********************************************************************!*\
  !*** ../loader-utils/src/lib/process-utils/child-process-proxy.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ChildProcessProxy; });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ 2);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* harmony import */ var _process_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./process-utils */ "../loader-utils/src/lib/process-utils/process-utils.js");
// Forked from probe.gl under MIT license, Copyright (c) 2015 - 2017 Uber Technologies, Inc.

/* eslint-disable no-console */
/* global process, setTimeout, clearTimeout, console */




const DEFAULT_PROCESS_OPTIONS = {
  command: null,
  arguments: [],
  portArg: null,
  port: 'auto',
  basePort: 5000,
  wait: 2000,
  nodeSpawnOptions: {maxBuffer: 5000 * 1024},
  onSuccess: processProxy => {
    console.log(`Started ${processProxy.options.command}`);
  }
};

class ChildProcessProxy {
  constructor({id = 'browser-driver'} = {}) {
    this.id = id;
    this.childProcess = null;
    this.port = null;
  }

  async start(options = {}) {
    options = {...DEFAULT_PROCESS_OPTIONS, ...options};
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(options.command && typeof options.command === 'string');
    this.options = options;

    const args = [...options.arguments];

    // If portArg is set, we can look up an available port
    this.port = options.port;
    if (options.portArg) {
      if (this.port === 'auto') {
        this.port = await Object(_process_utils__WEBPACK_IMPORTED_MODULE_2__["getAvailablePort"])(options.basePort);
      }
      args.push(options.portArg, this.port);
    }

    return await new Promise((resolve, reject) => {
      try {
        const successTimer = setTimeout(() => {
          if (options.onSuccess) {
            options.onSuccess(this);
          }
          resolve({});
        }, options.wait);

        console.log(`Spawning ${options.command} ${options.arguments.join(' ')}`);
        this.childProcess = child_process__WEBPACK_IMPORTED_MODULE_0___default.a.spawn(options.command, args, options.spawn);

        // TODO - add option regarding whether stderr should be treated as data
        this.childProcess.stderr.on('data', data => {
          console.log(`Child process wrote to stderr: "${data}".`);
          clearTimeout(successTimer);
          reject(new Error(data));
        });
        this.childProcess.on('error', error => {
          console.log(`Child process errored with ${error}`);
          clearTimeout(successTimer);
          reject(error);
        });
        this.childProcess.on('close', code => {
          console.log(`Child process exited with ${code}`);
          this.childProcess = null;
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  async stop() {
    if (this.childProcess) {
      this.childProcess.kill();
      this.childProcess = null;
    }
  }

  async exit(statusCode = 0) {
    try {
      await this.stop();
      // eslint-disable-next-line no-process-exit
      process.exit(statusCode);
    } catch (error) {
      console.error(error.message || error);
      // eslint-disable-next-line no-process-exit
      process.exit(1);
    }
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../loader-utils/src/lib/process-utils/process-utils.js":
/*!**************************************************************!*\
  !*** ../loader-utils/src/lib/process-utils/process-utils.js ***!
  \**************************************************************/
/*! exports provided: getAvailablePort */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAvailablePort", function() { return getAvailablePort; });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ 2);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);


// Get an available port
// Works on Unix systems
function getAvailablePort(defaultPort = 3000) {
  return new Promise((resolve, reject) => {
    // Get a list of all ports in use
    child_process__WEBPACK_IMPORTED_MODULE_0___default.a.exec('lsof -i -P -n | grep LISTEN', (error, stdout, stderr) => {
      if (error) {
        // likely no permission, e.g. CI
        resolve(defaultPort);
        return;
      }

      const portsInUse = [];
      const regex = /:(\d+) \(LISTEN\)/;
      stdout.split('\n').forEach(line => {
        const match = line.match(regex);
        if (match) {
          portsInUse.push(Number(match[1]));
        }
      });
      let port = defaultPort;
      while (portsInUse.includes(port)) {
        port++;
      }
      resolve(port);
    });
  });
}


/***/ }),

/***/ "../loader-utils/src/lib/request-utils/request-scheduler.js":
/*!******************************************************************!*\
  !*** ../loader-utils/src/lib/request-utils/request-scheduler.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RequestScheduler; });
/* harmony import */ var _probe_gl_stats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/stats */ "../../node_modules/@probe.gl/stats/dist/esm/index.js");
// TODO - this should move to core when test cases are more complete

/* global setTimeout */


const STAT_QUEUED_REQUESTS = 'Queued Requests';
const STAT_ACTIVE_REQUESTS = 'Active Requests';
const STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
const STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
const STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';

const DEFAULT_PROPS = {
  id: 'request-scheduler',
  // Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing
  throttleRequests: true,
  // The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.
  maxRequests: 6
};

// TODO - Track requests globally, across multiple servers
class RequestScheduler {
  constructor(props = {}) {
    this.props = {...DEFAULT_PROPS, ...props};

    // Tracks the number of active requests and prioritizes/cancels queued requests.
    this.requestQueue = [];
    this.activeRequestCount = 0;
    this.requestMap = new Map();

    // Returns the statistics used by the request scheduler.
    this.stats = new _probe_gl_stats__WEBPACK_IMPORTED_MODULE_0__["Stats"]({id: props.id});
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);

    this._deferredUpdate = null;
  }

  // Called by an application that wants to issue a request, without having it deeply queued
  // Parameter `getPriority` will be called when request "slots" open up,
  //    allowing the caller to update priority or cancel the request
  //    Highest priority executes first, priority < 0 cancels the request
  // Returns: a promise that resolves to a request token when the request can be issued without queueing,
  //    or `false` if the request has been cancelled (by getPriority)
  scheduleRequest(handle, getPriority = () => 0) {
    // Allows throttling to be disabled
    if (!this.props.throttleRequests) {
      return Promise.resolve({done: () => {}});
    }

    // dedupe
    if (this.requestMap.has(handle)) {
      return this.requestMap.get(handle);
    }

    const request = {handle, getPriority};
    const promise = new Promise(resolve => {
      request.resolve = resolve;
      return request;
    });

    this.requestQueue.push(request);
    this.requestMap.set(handle, promise);
    this._issueNewRequests();
    return promise;
  }

  // PRIVATE

  _issueRequest(request) {
    const {handle, resolve} = request;
    let isDone = false;

    const done = () => {
      // can only be called once
      if (!isDone) {
        isDone = true;

        // Stop tracking a request - it has completed, failed, cancelled etc
        this.requestMap.delete(handle);
        this.activeRequestCount--;
        // A slot just freed up, see if any queued requests are waiting
        this._issueNewRequests();
      }
    };

    // Track this request
    this.activeRequestCount++;

    return resolve ? resolve({done}) : Promise.resolve({done});
  }

  // We check requests asynchronously, to prevent multiple updates
  _issueNewRequests() {
    if (!this._deferredUpdate) {
      this._deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
    }
  }

  // Refresh all requests and
  _issueNewRequestsAsync() {
    this._deferredUpdate = null;

    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);

    if (freeSlots === 0) {
      return;
    }

    this._updateAllRequests();

    // Resolve pending promises for the top-priority requests
    for (let i = 0; i < freeSlots; ++i) {
      if (this.requestQueue.length > 0) {
        const request = this.requestQueue.shift();
        this._issueRequest(request);
      }
    }

    // Uncomment to debug
    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);
  }

  // Ensure all requests have updated priorities, and that no longer valid requests are cancelled
  _updateAllRequests() {
    const requestQueue = this.requestQueue;
    for (let i = 0; i < requestQueue.length; ++i) {
      const request = requestQueue[i];
      if (!this._updateRequest(request)) {
        // Remove the element and make sure to adjust the counter to account for shortened array
        requestQueue.splice(i, 1);
        this.requestMap.delete(request.handle);
        i--;
      }
    }

    // Sort the remaining requests based on priority
    requestQueue.sort((a, b) => a.priority - b.priority);
  }

  // Update a single request by calling the callback
  _updateRequest(request) {
    request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return

    // by returning a negative priority, the callback cancels the request
    if (request.priority < 0) {
      request.resolve(null);
      return false;
    }
    return true;
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-loader-utils/create-worker.js":
/*!********************************************************************!*\
  !*** ../loader-utils/src/lib/worker-loader-utils/create-worker.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createWorker; });
/* harmony import */ var _worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../worker-utils/get-transfer-list */ "../loader-utils/src/lib/worker-utils/get-transfer-list.js");
/* harmony import */ var _validate_loader_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validate-loader-version */ "../loader-utils/src/lib/worker-loader-utils/validate-loader-version.js");
/* eslint-disable no-restricted-globals */
/* global TextDecoder, self */




function createWorker(loader) {
  // TODO - explain when this happens? Just a sanity check? Throw an error or log a warning?
  if (typeof self === 'undefined') {
    return;
  }

  let requestId = 0;
  const parse = (arraybuffer, options = {}, url) =>
    new Promise((resolve, reject) => {
      const id = requestId++;

      const onMessage = ({data}) => {
        if (!data || data.id !== id) {
          // not ours
          return;
        }
        switch (data.type) {
          case 'parse-done':
            self.removeEventListener('message', onMessage);
            resolve(data.result);
            break;

          case 'parse-error':
            self.removeEventListener('message', onMessage);
            reject(data.message);
            break;

          default:
          // ignore
        }
      };
      self.addEventListener('message', onMessage);
      // Ask the main thread to decode data
      // @ts-ignore self is WorkerGlobalScope
      self.postMessage({type: 'parse', id, arraybuffer, options, url}, [arraybuffer]);
    });

  self.onmessage = async evt => {
    const {data} = evt;

    try {
      if (!isKnownMessage(data, loader.name)) {
        return;
      }

      Object(_validate_loader_version__WEBPACK_IMPORTED_MODULE_1__["validateLoaderVersion"])(loader, data.source.split('@')[1]);

      const {arraybuffer, byteOffset = 0, byteLength = 0, options = {}} = data;

      const result = await parseData({
        loader,
        arraybuffer,
        byteOffset,
        byteLength,
        options,
        context: {parse}
      });
      const transferList = Object(_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__["getTransferList"])(result);
      // @ts-ignore self is WorkerGlobalScope
      self.postMessage({type: 'done', result}, transferList);
    } catch (error) {
      // @ts-ignore self is WorkerGlobalScope
      self.postMessage({type: 'error', message: error.message});
    }
  };
}

// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)
// TODO - Why not support async loader.parse* funcs here?
// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?
// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse
async function parseData({loader, arraybuffer, byteOffset, byteLength, options, context}) {
  let data;
  let parser;
  if (loader.parseSync || loader.parse) {
    data = arraybuffer;
    parser = loader.parseSync || loader.parse;
  } else if (loader.parseTextSync) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(arraybuffer);
    parser = loader.parseTextSync;
  } else {
    throw new Error(`Could not load data with ${loader.name} loader`);
  }

  // TODO - proper merge in of loader options...
  options = {
    ...options,
    modules: (loader && loader.options && loader.options.modules) || {},
    worker: false
  };

  return await parser(data, {...options}, context, loader);
}

// Filter out noise messages sent to workers
function isKnownMessage(data, name) {
  return data && data.type === 'parse' && data.source && data.source.startsWith('loaders.gl');
}

/*
function checkMessage(evt, name) {
  switch (evt.data && evt.data.source) {
    // Ignore known noise event from react-dev-tools bridge, webpack build progress etc...
    case 'react-devtools-bridge':
    case 'react-devtools-content-script':
    case 'react-devtools-detector':
      return false;
    default:
      // fall through
  }

  switch (evt.data && evt.data.type) {
    case 'webpackProgress':
    case 'webpackOk':
      return false;
    default:
      // Enable to debug messages
      // const message = `${name.toLowerCase()}-worker: ignoring unknown message`;
      // console.log(message, evt.data, evt); // eslint-disable-line
      return false;
  }
}
*/


/***/ }),

/***/ "../loader-utils/src/lib/worker-loader-utils/validate-loader-version.js":
/*!******************************************************************************!*\
  !*** ../loader-utils/src/lib/worker-loader-utils/validate-loader-version.js ***!
  \******************************************************************************/
/*! exports provided: validateLoaderVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateLoaderVersion", function() { return validateLoaderVersion; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");


// __VERSION__ is injected by babel-plugin-version-inline

// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.13" : undefined;

// Returns `true` if the two versions are compatible
function validateLoaderVersion(loader, coreVersion = VERSION) {
  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(loader, 'no loader provided');

  let loaderVersion = loader.version;
  if (!coreVersion || !loaderVersion) {
    return;
  }

  coreVersion = parseVersion(coreVersion);
  loaderVersion = parseVersion(loaderVersion);

  // TODO enable when fix the __version__ injection
  // assert(
  //   coreVersion.major === loaderVersion.major && coreVersion.minor <= loaderVersion.minor,
  //   `loader: ${loader.name} is not compatible. ${coreVersion.major}.${
  //     coreVersion.minor
  //   }+ is required.`
  // );
}

function parseVersion(version) {
  const parts = version.split('.').map(Number);
  return {major: parts[0], minor: parts[1]};
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/get-transfer-list.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/get-transfer-list.js ***!
  \*****************************************************************/
/*! exports provided: getTransferList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return getTransferList; });
// NOTE - there is a copy of this function is both in core and loader-utils
// core does not need all the utils in loader-utils, just this one.

/* global MessagePort, ImageBitmap, OffscreenCanvas */

// Returns an array of Transferrable objects that can be used with postMessage
// https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
function getTransferList(object, recursive = true, transfers) {
  // Make sure that items in the transfer list is unique
  const transfersSet = transfers || new Set();

  if (!object) {
    // ignore
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    // Typed array
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)
    // Do not iterate through the content in this case
  } else if (recursive && typeof object === 'object') {
    for (const key in object) {
      // Avoid perf hit - only go one level deep
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  // If transfers is defined, is internal recursive call
  // Otherwise it's called by the user
  return transfers === undefined ? Array.from(transfersSet) : [];
}

// https://developer.mozilla.org/en-US/docs/Web/API/Transferable
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/get-worker-url.js":
/*!**************************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/get-worker-url.js ***!
  \**************************************************************/
/*! exports provided: getWorkerURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWorkerURL", function() { return getWorkerURL; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* global URL, Blob */


const workerURLCache = new Map();

// Creates a URL from worker source that can be used to create `Worker` instances
// Packages (and then caches) the result of `webworkify` as an "Object URL"
function getWorkerURL(workerSource, workerName = 'Worker') {
  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof workerSource === 'string', 'worker source');

  // CASE: url(./worker.js)
  // This pattern is used to differentiate worker urls from worker source code
  // Load from url is needed for testing, when using Webpack & webworker target
  if (workerSource.startsWith('url(') && workerSource.endsWith(')')) {
    const workerUrl = workerSource.match(/^url\((.*)\)$/)[1];

    // A local script url, we can use it to initialize a Worker directly
    if (workerUrl && !workerUrl.startsWith('http')) {
      return workerUrl;
    }

    // Per spec, worker cannot be initialized with a script from a different origin
    // However a local worker script can still import scripts from other origins,
    // so we simply build a wrapper script
    workerSource = buildScript(workerUrl);
  }

  let workerURL = workerURLCache.get(workerSource);

  if (!workerURL) {
    // NOTE: webworkify was previously used
    // const blob = webworkify(workerSource, {bare: true});
    const blob = new Blob([workerSource], {type: 'application/javascript'});
    workerURL = URL.createObjectURL(blob);
    workerURLCache.set(workerSource, workerURL);
  }

  return workerURL;
}

// Only use trusted sources!
function buildScript(workerUrl) {
  return `\
try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
}`;
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/worker-farm.js":
/*!***********************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/worker-farm.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerFarm; });
/* harmony import */ var _worker_pool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-pool */ "../loader-utils/src/lib/worker-utils/worker-pool.js");


const DEFAULT_MAX_CONCURRENCY = 5;

/**
 * Process multiple data messages with a "farm" of different workers (in worker pools)
 */
class WorkerFarm {
  static isSupported() {
    return typeof Worker !== 'undefined';
  }

  constructor({
    maxConcurrency = DEFAULT_MAX_CONCURRENCY,
    onMessage = null,
    onDebug = () => {},
    reuseWorkers = true
  }) {
    this.maxConcurrency = maxConcurrency;
    this.onMessage = onMessage;
    this.onDebug = onDebug;
    this.workerPools = new Map();
    this.reuseWorkers = reuseWorkers;
  }

  setProps(props) {
    if ('maxConcurrency' in props) {
      this.maxConcurrency = props.maxConcurrency;
    }

    if ('onDebug' in props) {
      this.onDebug = props.onDebug;
    }

    if ('reuseWorkers' in props) {
      this.reuseWorkers = props.reuseWorkers;
    }
  }

  destroy() {
    this.workerPools.forEach(workerPool => workerPool.destroy());
  }

  /**
   * Process binary data in a worker
   * @param {any} data - data (containing binary typed arrays) to be transferred to worker
   * @returns a Promise with data containing typed arrays transferred back from work
   */
  async process(workerSource, workerName, data) {
    const workerPool = this._getWorkerPool(workerSource, workerName);
    return workerPool.process(data);
  }

  // PRIVATE

  _getWorkerPool(workerSource, workerName) {
    let workerPool = this.workerPools.get(workerName);
    if (!workerPool) {
      workerPool = new _worker_pool__WEBPACK_IMPORTED_MODULE_0__["default"]({
        source: workerSource,
        name: workerName,
        onMessage: onWorkerMessage.bind(null, this.onMessage),
        maxConcurrency: this.maxConcurrency,
        onDebug: this.onDebug,
        reuseWorkers: this.reuseWorkers
      });
      this.workerPools.set(workerName, workerPool);
    }
    return workerPool;
  }
}

function onWorkerMessage(onMessage, {worker, data, resolve, reject}) {
  if (onMessage) {
    onMessage({worker, data, resolve, reject});
    return;
  }

  switch (data.type) {
    case 'done':
      resolve(data.result);
      break;

    case 'error':
      reject(data.message);
      break;

    default:
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/worker-pool.js":
/*!***********************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/worker-pool.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerPool; });
/* harmony import */ var _worker_thread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-thread */ "../loader-utils/src/lib/worker-utils/worker-thread.js");


/**
 * Process multiple data messages with small pool of identical workers
 */
class WorkerPool {
  constructor({
    source,
    name = 'unnamed',
    maxConcurrency = 1,
    onMessage,
    onDebug = () => {},
    reuseWorkers = true
  }) {
    this.source = source;
    this.name = name;
    this.maxConcurrency = maxConcurrency;
    this.onMessage = onMessage;
    this.onDebug = onDebug;

    this.jobQueue = [];
    this.idleQueue = [];
    this.count = 0;
    this.isDestroyed = false;
    this.reuseWorkers = reuseWorkers;
  }

  destroy() {
    // Destroy idle workers, active Workers will be destroyed on completion
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }

  /**
   * Process binary data in a worker
   */
  process(data, jobName) {
    return new Promise((resolve, reject) => {
      this.jobQueue.push({data, jobName, resolve, reject});
      this._startQueuedJob();
    });
  }

  // PRIVATE

  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const worker = this._getAvailableWorker();
    if (!worker) {
      return;
    }

    // We have a worker, dequeue and start the job
    const job = this.jobQueue.shift();

    // @ts-ignore
    this.onDebug({
      message: 'processing',
      worker: worker.name,
      job: job.jobName,
      backlog: this.jobQueue.length
    });

    try {
      job.resolve(await worker.process(job.data));
    } catch (error) {
      job.reject(error);
    } finally {
      this._onWorkerDone(worker);
    }
  }

  _onWorkerDone(worker) {
    if (this.isDestroyed) {
      worker.destroy();
      return;
    }

    if (this.reuseWorkers) {
      this.idleQueue.push(worker);
    } else {
      worker.destroy();
      this.count--;
    }

    this._startQueuedJob();
  }

  _getAvailableWorker() {
    // If a worker has completed and returned to the queue, it can be used
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift();
    }

    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source
    if (this.count < this.maxConcurrency) {
      this.count++;
      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new _worker_thread__WEBPACK_IMPORTED_MODULE_0__["default"]({source: this.source, onMessage: this.onMessage, name});
    }

    // No worker available, have to wait
    return null;
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/worker-thread.js":
/*!*************************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/worker-thread.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerThread; });
/* harmony import */ var _get_worker_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-worker-url */ "../loader-utils/src/lib/worker-utils/get-worker-url.js");
/* harmony import */ var _get_transfer_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-transfer-list */ "../loader-utils/src/lib/worker-utils/get-transfer-list.js");
/* global Worker */



let count = 0;

// By default resolves to the first message the worker sends back
function defaultOnMessage({data, resolve}) {
  resolve(data);
}

class WorkerThread {
  constructor({source, name = `web-worker-${count++}`, onMessage}) {
    const url = Object(_get_worker_url__WEBPACK_IMPORTED_MODULE_0__["getWorkerURL"])(source, name);
    this.worker = new Worker(url, {name});
    this.name = name;
    this.onMessage = onMessage || defaultOnMessage;
  }

  /**
   * Process binary data in a worker
   */
  async process(data) {
    return new Promise((resolve, reject) => {
      this.worker.onmessage = event => {
        this.onMessage({worker: this.worker, data: event.data, resolve, reject});
      };
      this.worker.onerror = error => {
        // Note Error object does not have the expected fields if loading failed completely
        // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers
        // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent
        let message = `${this.name}: WorkerThread.process() failed`;
        if (error.message) {
          message += ` ${error.message} ${error.filename}:${error.lineno}:${error.colno}`;
        }
        const betterError = new Error(message);
        console.error(error); // eslint-disable-line
        reject(betterError);
      };
      const transferList = Object(_get_transfer_list__WEBPACK_IMPORTED_MODULE_1__["getTransferList"])(data);
      this.worker.postMessage(data, transferList);
    });
  }

  destroy() {
    this.worker.terminate();
    // @ts-ignore
    this.worker = null;
  }
}


/***/ }),

/***/ "../tables/src/index.js":
/*!******************************!*\
  !*** ../tables/src/index.js ***!
  \******************************/
/*! exports provided: Schema, Field, deduceTableSchema, TableBatchBuilder, RowTableBatch, ColumnarTableBatch, JSONLoader, XMLLoader, AsyncQueue, getTypeInfo, DataType, Null, Bool, Int, Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float, Float16, Float32, Float64, Utf8, Date, DateDay, DateMillisecond, Time, TimeMillisecond, TimeSecond, Timestamp, TimestampSecond, TimestampMillisecond, TimestampMicrosecond, TimestampNanosecond, Interval, IntervalDayTime, IntervalYearMonth, FixedSizeList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_schema_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/schema/schema */ "../tables/src/lib/schema/schema.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Schema", function() { return _lib_schema_schema__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_schema_field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/schema/field */ "../tables/src/lib/schema/field.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return _lib_schema_field__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_schema_schema_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/schema/schema-utils */ "../tables/src/lib/schema/schema-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deduceTableSchema", function() { return _lib_schema_schema_utils__WEBPACK_IMPORTED_MODULE_2__["deduceTableSchema"]; });

/* harmony import */ var _lib_table_table_batch_builder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/table/table-batch-builder */ "../tables/src/lib/table/table-batch-builder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TableBatchBuilder", function() { return _lib_table_table_batch_builder__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _lib_table_row_table_batch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/table/row-table-batch */ "../tables/src/lib/table/row-table-batch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RowTableBatch", function() { return _lib_table_row_table_batch__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _lib_table_columnar_table_batch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/table/columnar-table-batch */ "../tables/src/lib/table/columnar-table-batch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColumnarTableBatch", function() { return _lib_table_columnar_table_batch__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _json_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./json-loader */ "../tables/src/json-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return _json_loader__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _xml_loader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./xml-loader */ "../tables/src/xml-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XMLLoader", function() { return _xml_loader__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _lib_utils_async_queue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/utils/async-queue */ "../tables/src/lib/utils/async-queue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AsyncQueue", function() { return _lib_utils_async_queue__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _lib_types_type_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/types/type-utils */ "../tables/src/lib/types/type-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTypeInfo", function() { return _lib_types_type_utils__WEBPACK_IMPORTED_MODULE_9__["getTypeInfo"]; });

/* harmony import */ var _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/types/arrow-like/type */ "../tables/src/lib/types/arrow-like/type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["DataType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Null", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Null"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bool", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Bool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int8", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int16", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int32", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int64", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Uint8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint16", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Uint16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint32", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Uint32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint64", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Uint64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Float"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float16", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Float16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float32", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Float32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float64", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Float64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Utf8", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Utf8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Date", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Date"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateDay", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["DateDay"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateMillisecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["DateMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Time", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Time"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeMillisecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimeMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeSecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimeSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Timestamp", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Timestamp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampSecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimestampSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampMillisecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimestampMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampMicrosecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimestampMicrosecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampNanosecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimestampNanosecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Interval"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalDayTime", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["IntervalDayTime"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalYearMonth", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["IntervalYearMonth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FixedSizeList", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["FixedSizeList"]; });





// TABLE CATEGORY UTILS




// EXPERIMENTAL MICRO-LOADERS



// EXPERIMENTAL APIs


// TYPES





/***/ }),

/***/ "../tables/src/json-loader.js":
/*!************************************!*\
  !*** ../tables/src/json-loader.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// TODO - deprecated
function parseTextSync(text, options) {
  return JSON.parse(text);
}

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'JSON',
  extensions: ['json'],
  testText: null,
  parseTextSync
});


/***/ }),

/***/ "../tables/src/lib/schema/field.js":
/*!*****************************************!*\
  !*** ../tables/src/lib/schema/field.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Field; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../tables/src/lib/utils/assert.js");
/* harmony import */ var _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/arrow-like/type */ "../tables/src/lib/types/arrow-like/type.js");



// ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)
// https://loaders.gl/arrowjs/docs/api-reference/field
// A field holds name, nullable, and metadata information about a table "column"
// A Schema is essentially a list of fields

class Field {
  constructor(name, type = null, nullable = false, metadata = new Map()) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof name === 'string');
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(!type || type instanceof _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_1__["DataType"]);
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof nullable === 'boolean');
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(!metadata || typeof metadata === 'object');

    this.name = name;
    this.type = type;
    this.nullable = nullable;
    this.metadata = metadata;
  }

  get typeId() {
    return this.type && this.type.typeId;
  }

  clone() {
    return new Field(this.name, this.type, this.nullable, this.metadata);
  }

  compareTo(other) {
    return (
      this.name === other.name &&
      this.type === other.type &&
      this.nullable === other.nullable &&
      this.metadata === other.metadata
    );
  }

  toString() {
    return `${this.type}${this.nullable ? ', nullable' : ''}${
      this.metadata ? `, metadata: ${this.metadata}` : ''
    }`;
  }
}


/***/ }),

/***/ "../tables/src/lib/schema/schema-utils.js":
/*!************************************************!*\
  !*** ../tables/src/lib/schema/schema-utils.js ***!
  \************************************************/
/*! exports provided: deduceTableSchema */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deduceTableSchema", function() { return deduceTableSchema; });
/* harmony import */ var _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/arrow-like/type */ "../tables/src/lib/types/arrow-like/type.js");
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema */ "../tables/src/lib/schema/schema.js");
/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./field */ "../tables/src/lib/schema/field.js");
// SCHEMA SUPPORT - AUTODEDUCTION




const TYPED_ARRAY_TO_TYPE = {
  Int8Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Int8"](),
  Int16Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Int16"](),
  Int32Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Int32"](),
  Uint8Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint8"](),
  Uint8ClampedArray: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint8"](),
  Uint16Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint16"](),
  Uint32Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint32"](),
  Float32Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Float32"](),
  Float64Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Float64"]()
};

if (typeof BigInt64Array !== 'undefined') {
  TYPED_ARRAY_TO_TYPE.BigInt64Array = new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Int64"]();
  TYPED_ARRAY_TO_TYPE.BigUint64Array = new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint64"]();
}

// Type deduction

/**
 * Type deduction from columnar array
 *
 * Notes:
 * - If the column is a typed array we are able to make a fairly precise type deduction
 * - However we can't tell if it is intervals, dates, fixed size lists etc.
 * - Nullable typed arrays are only supported if backing table is Arrow
 *
 * @param {*} columnArray
 * @returns type, nullable, metadata - (Arrow-like) type information
 */
function getTypeFromColumnArray(columnArray) {
  const ArrayType = columnArray.constructor && columnArray.constructor.name;
  let type = TYPED_ARRAY_TO_TYPE[ArrayType];
  if (type) {
    return {type, nullable: false, metadata: null};
  }

  let metadata = null;
  if (columnArray.length > 0) {
    const value = columnArray[0];
    type = deduceTypeFromValue(value);
    if (type) {
      metadata = new Map([['type', type.toString()]]);
    }
  }

  // We use fields of Arrow-Type Null to indicate that we represent additional, non binary columns
  return {type: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Null"](), nullable: true, metadata};
}

function deduceTableSchema(table, schema = null) {
  const deducedSchema = Array.isArray(table)
    ? deduceSchemaForRowTable(table)
    : deduceSchemaForColumnarTable(table);
  // Deduced schema will fill in missing info from partial options.schema, if provided
  return Object.assign(deducedSchema, schema);
}

function deduceSchemaForColumnarTable(columnarTable) {
  const fields = [];
  for (const columnName in columnarTable) {
    const columnArray = columnarTable[columnName];
    const {type, nullable, metadata} = getTypeFromColumnArray(columnArray);
    fields.push(new _field__WEBPACK_IMPORTED_MODULE_2__["default"](columnName, type, nullable, metadata || new Map()));
  }
  return new _schema__WEBPACK_IMPORTED_MODULE_1__["default"](fields);
}

function deduceSchemaForRowTable(rowTable) {
  const fields = [];
  if (rowTable.length) {
    const row = rowTable[0];
    // Note - handle rows in both array and object format
    if (Array.isArray(row)) {
      // row: [value1, value2, ...]
      for (let columnIndex = 0; columnIndex < row.length; ++columnIndex) {
        const value = row[columnIndex];
        const name = String(columnIndex);
        const type = deduceTypeFromValue(value);
        const nullable = true;
        const metadata = new Map([['type', type.toString()]]);
        fields.push(new _field__WEBPACK_IMPORTED_MODULE_2__["default"](name, new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Null"](), nullable, metadata));
      }
    } else {
      for (const columnName in row) {
        // row: {columnName1: value1, columnName2: value2, ...}
        // TODO - Could look at additional rows if nulls in first row
        const value = row[columnName];
        const type = deduceTypeFromValue(value);
        const nullable = true;
        const metadata = new Map([['type', type.toString()]]);
        fields.push(new _field__WEBPACK_IMPORTED_MODULE_2__["default"](columnName, new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Null"](), nullable, metadata));
      }
    }
  }
  return new _schema__WEBPACK_IMPORTED_MODULE_1__["default"](fields);
}

function deduceTypeFromValue(value) {
  if (value === true || value === false) {
    return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Bool"]();
  }
  if (value instanceof Date) {
    return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["TimestampMillisecond"]();
  }
  if (value instanceof Number) {
    return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Float32"]();
  }
  if (typeof value === 'string') {
    return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Utf8"]();
  }
  // TODO JS columns (arrays and object valued) are currently null
  return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Null"]();
}


/***/ }),

/***/ "../tables/src/lib/schema/schema.js":
/*!******************************************!*\
  !*** ../tables/src/lib/schema/schema.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Schema; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../tables/src/lib/utils/assert.js");


// ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)
// https://loaders.gl/arrowjs/docs/api-reference/schema
class Schema {
  constructor(fields, metadata = null) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(Array.isArray(fields));
    checkNames(fields);
    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`
    this.fields = fields;
    this.metadata = metadata || new Map();
  }

  // TODO - arrow only seems to compare fields
  compareTo(other) {
    if (this.fields.metadata !== other.fields.metadata) {
      return false;
    }
    if (this.fields.length !== other.fields.length) {
      return false;
    }
    for (let i = 0; i < this.fields.length; ++i) {
      if (!this.fields[i].compareTo(other.fields[i])) {
        return false;
      }
    }
    return true;
  }

  select(...columnNames) {
    // Ensure column names reference valid fields
    const nameMap = Object.create(null);
    for (const name of columnNames) {
      nameMap[name] = true;
    }
    const selectedFields = columnNames.filter(field => nameMap[field.name]);
    return new Schema(selectedFields, this.metadata);
  }

  selectAt(...columnIndices) {
    // Ensure column indices reference valid fields
    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);
    return new Schema(selectedFields, this.metadata);
  }

  assign(schemaOrFields) {
    let metadata = this.metadata;

    let fields = schemaOrFields;
    if (schemaOrFields instanceof Schema) {
      const otherSchema = schemaOrFields;
      fields = otherSchema.fields;
      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);
    }

    // Create a merged list of fields, overwrite fields in place, new fields at end
    const fieldMap = Object.create(null);

    for (const field of this.fields) {
      fieldMap[field.name] = field;
    }

    for (const field of fields) {
      fieldMap[field.name] = field;
    }

    const mergedFields = Object.values(fieldMap);

    return new Schema(mergedFields, metadata);
  }
}

// Warn if any duplicated field names
function checkNames(fields) {
  const usedNames = {};
  for (const field of fields) {
    if (usedNames[field.name]) {
      // eslint-disable-next-line
      console.warn('Schema: duplicated field name', field.name, field);
    }
    usedNames[field.name] = true;
  }
}

function mergeMaps(m1, m2) {
  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);
}


/***/ }),

/***/ "../tables/src/lib/table/columnar-table-batch.js":
/*!*******************************************************!*\
  !*** ../tables/src/lib/table/columnar-table-batch.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColumnarTableBatch; });
class ColumnarTableBatch {
  constructor(schema, options = {}) {
    this.schema = schema;
    this.batchSize = options.batchSize || 'auto';

    this.length = 0;
    this.allocated = 0;
    this.columns = null;
    this.isChunkComplete = false;

    this.reallocateColumns();
  }

  addRow(row) {
    // If user keeps pushing rows beyond batch size, reallocate
    this.reallocateColumns();
    for (const fieldName in row) {
      this.columns[fieldName][this.length] = row[fieldName];
    }
    this.length++;
  }

  // Is this TableBatch full?
  chunkComplete() {
    this.isChunkComplete = true;
  }

  isFull() {
    if (this.batchSize === 'auto') {
      return this.isChunkComplete;
    }
    return this.length >= this.allocated;
  }

  getBatch(options = {}) {
    this.pruneColumns();
    const columns = Array.isArray(this.schema) ? this.columns : {};

    // schema is an array if there're no headers
    // object if there are headers
    // columns should match schema format
    if (!Array.isArray(this.schema)) {
      for (const fieldName in this.schema) {
        const field = this.schema[fieldName];
        columns[field.name] = this.columns[field.index];
      }
    }

    this.columns = null;
    this.isChunkComplete = false;

    return {data: columns, schema: this.schema, length: this.length};
  }

  // HELPERS

  reallocateColumns() {
    if (this.length < this.allocated) {
      return;
    }

    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : this.batchSize;
    this.columns = [];

    for (const fieldName in this.schema) {
      const field = this.schema[fieldName];
      const ArrayType = field.type || Float32Array;
      const oldColumn = this.columns[field.index];

      if (oldColumn && ArrayBuffer.isView(oldColumn)) {
        // Copy the old data to the new array
        const typedArray = new ArrayType(this.allocated);
        typedArray.set(oldColumn);
        this.columns[field.index] = typedArray;
      } else if (oldColumn) {
        // Plain array
        oldColumn.length = this.allocated;
        this.columns[field.index] = oldColumn;
      } else {
        // Create new
        this.columns[field.index] = new ArrayType(this.allocated);
      }
    }
  }

  pruneColumns() {
    this.columns = this.columns.map(column => column.slice(0, this.length));
  }
}


/***/ }),

/***/ "../tables/src/lib/table/row-table-batch.js":
/*!**************************************************!*\
  !*** ../tables/src/lib/table/row-table-batch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RowTableBatch; });
const DEFAULT_OPTIONS = {
  batchSize: 'auto',
  convertToObject: true,
  // optimizes memory usage but increases parsing time.
  optimizeMemoryUsage: false
};

class RowTableBatch {
  constructor(schema, options = {}) {
    options = {...DEFAULT_OPTIONS, ...options};

    this.schema = schema;
    this.batchSize = options.batchSize;
    this.convertToObject = options.convertToObject;
    this.optimizeMemoryUsage = options.optimizeMemoryUsage;

    this.rows = null;
    this.length = 0;
    this.isChunkComplete = false;
    this.cursor = 0;

    // schema is an array if there're no headers
    // object if there are headers
    if (!Array.isArray(schema)) {
      this._headers = [];
      for (const key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  addRow(row, cursor = null) {
    if (!this.rows) {
      this.rows = new Array(this.batchSize);
      this.length = 0;
    }
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }

    // We can only convert if we were given a schema
    const convertToObject = this.convertToObject && this.schema;
    this.rows[this.length] = convertToObject ? convertRowToObject(row, this._headers) : row;

    if (this.optimizeMemoryUsage) {
      // A workaround to allocate new strings and don't retain pointers to original strings.
      // https://bugs.chromium.org/p/v8/issues/detail?id=2869
      this.rows[this.length] = JSON.parse(JSON.stringify(this.rows[this.length]));
    }

    this.length++;
  }

  chunkComplete() {
    this.isChunkComplete = true;
  }

  isFull() {
    if (this.batchSize === 'auto') {
      return this.isChunkComplete && this.length > 0;
    }
    return this.rows && this.length >= this.batchSize;
  }

  getBatch() {
    if (this.rows) {
      const rows = this.rows.slice(0, this.length);
      this.rows = null;
      this.isChunkComplete = false;
      return {data: rows, schema: this.schema, length: rows.length, cursor: this.cursor};
    }
    return null;
  }
}

function convertRowToObject(row, headers) {
  if (!row) {
    throw new Error('null row');
  }
  if (!Array.isArray(row)) {
    return row;
  }

  if (!headers) {
    return row;
  }
  const result = {};
  for (let i = 0; i < headers.length; i++) {
    result[headers[i]] = row[i];
  }
  return result;
}


/***/ }),

/***/ "../tables/src/lib/table/table-batch-builder.js":
/*!******************************************************!*\
  !*** ../tables/src/lib/table/table-batch-builder.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TableBatchBuilder; });
const DEFAULT_BATCH_SIZE = 100;

const DEFAULT_OPTIONS = {
  batchSize: DEFAULT_BATCH_SIZE
};

class TableBatchBuilder {
  constructor(TableBatchType, schema, options = {}) {
    this.TableBatchType = TableBatchType;
    this.schema = schema;
    this.options = {...DEFAULT_OPTIONS, ...options};

    this.batch = null;
    this.batchCount = 0;
    this.bytesUsed = 0;
  }

  addRow(row) {
    if (!this.batch) {
      const {TableBatchType} = this;
      this.batch = new TableBatchType(this.schema, this.options);
    }

    this.batch.addRow(row);
  }

  chunkComplete(chunk) {
    this.bytesUsed += chunk.byteLength || chunk.length || 0;
    if (this.batch) {
      this.batch.chunkComplete();
    }
  }

  isFull() {
    return this.batch && this.batch.isFull();
  }

  hasBatch() {
    return Boolean(this.batch);
  }

  getBatch(options = {}) {
    if (Number.isFinite(options.bytesUsed)) {
      this.bytesUsed = options.bytesUsed;
    }

    if (this.batch) {
      const normalizedBatch = this.batch.getBatch();
      this.batch = null;
      normalizedBatch.count = this.batchCount;
      this.batchCount++;
      normalizedBatch.bytesUsed = this.bytesUsed;
      Object.assign(normalizedBatch, options);
      return normalizedBatch;
    }

    return null;
  }
}


/***/ }),

/***/ "../tables/src/lib/types/arrow-like/enum.js":
/*!**************************************************!*\
  !*** ../tables/src/lib/types/arrow-like/enum.js ***!
  \**************************************************/
/*! exports provided: Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return Type; });
// This code is adapted from ArrowJS https://github.com/apache/arrow
// under Apache license http://www.apache.org/licenses/LICENSE-2.0

/**
 * Main data type enumeration.
 *
 * Data types in this library are all *logical*. They can be expressed as
 * either a primitive physical type (bytes or bits of some fixed size), a
 * nested type consisting of other data types, or another data type (e.g. a
 * timestamp encoded as an int64).
 *
 * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow
 * IPC payload.
 *
 * The rest of the values are specified here so TypeScript can narrow the type
 * signatures further beyond the base Arrow Types. The Arrow DataTypes include
 * metadata like `bitWidth` that impact the type signatures of the values we
 * accept and return.
 *
 * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an
 * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`
 * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the
 * underlying `Int32Array`.
 *
 * Library consumers benefit by knowing the narrowest type, since we can ensure
 * the types across all public methods are propagated, and never bail to `any`.
 * These values are _never_ used at runtime, and they will _never_ be written
 * to the flatbuffers metadata of serialized Arrow IPC payloads.
 */
const Type = {
  /** The default placeholder type */
  NONE: 0,
  /** A NULL type having no physical storage */
  Null: 1,
  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */
  Int: 2,
  /** 2, 4, or 8-byte floating point value */
  Float: 3,
  /** Variable-length bytes (no guarantee of UTF8-ness) */
  Binary: 4,
  /** UTF8 variable-length string as List<Char> */
  Utf8: 5,
  /** Boolean as 1 bit, LSB bit-packed ordering */
  Bool: 6,
  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */
  Decimal: 7,
  /** int32_t days or int64_t milliseconds since the UNIX epoch */
  Date: 8,
  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */
  Time: 9,
  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */
  Timestamp: 10,
  /** YEAR_MONTH or DAY_TIME interval in SQL style */
  Interval: 11,
  /** A list of some logical data type */
  List: 12,
  /** Struct of logical types */
  Struct: 13,
  /** Union of logical types */
  Union: 14,
  /** Fixed-size binary. Each value occupies the same number of bytes */
  FixedSizeBinary: 15,
  /** Fixed-size list. Each value occupies the same number of bytes */
  FixedSizeList: 16,
  /** Map of named logical types */
  Map: 17,

  /** Dictionary aka Category type */
  Dictionary: -1,
  Int8: -2,
  Int16: -3,
  Int32: -4,
  Int64: -5,
  Uint8: -6,
  Uint16: -7,
  Uint32: -8,
  Uint64: -9,
  Float16: -10,
  Float32: -11,
  Float64: -12,
  DateDay: -13,
  DateMillisecond: -14,
  TimestampSecond: -15,
  TimestampMillisecond: -16,
  TimestampMicrosecond: -17,
  TimestampNanosecond: -18,
  TimeSecond: -19,
  TimeMillisecond: -20,
  TimeMicrosecond: -21,
  TimeNanosecond: -22,
  DenseUnion: -23,
  SparseUnion: -24,
  IntervalDayTime: -25,
  IntervalYearMonth: -26
};


/***/ }),

/***/ "../tables/src/lib/types/arrow-like/type.js":
/*!**************************************************!*\
  !*** ../tables/src/lib/types/arrow-like/type.js ***!
  \**************************************************/
/*! exports provided: DataType, Null, Bool, Int, Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float, Float16, Float32, Float64, Utf8, Date, DateDay, DateMillisecond, Time, TimeSecond, TimeMillisecond, Timestamp, TimestampSecond, TimestampMillisecond, TimestampMicrosecond, TimestampNanosecond, Interval, IntervalDayTime, IntervalYearMonth, FixedSizeList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return DataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Null", function() { return Null; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bool", function() { return Bool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int", function() { return Int; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8", function() { return Int8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16", function() { return Int16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32", function() { return Int32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int64", function() { return Int64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8", function() { return Uint8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16", function() { return Uint16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32", function() { return Uint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint64", function() { return Uint64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float", function() { return Float; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float16", function() { return Float16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32", function() { return Float32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64", function() { return Float64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Utf8", function() { return Utf8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Date", function() { return Date; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateDay", function() { return DateDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateMillisecond", function() { return DateMillisecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Time", function() { return Time; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeSecond", function() { return TimeSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeMillisecond", function() { return TimeMillisecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timestamp", function() { return Timestamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampSecond", function() { return TimestampSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampMillisecond", function() { return TimestampMillisecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampMicrosecond", function() { return TimestampMicrosecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampNanosecond", function() { return TimestampNanosecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return Interval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalDayTime", function() { return IntervalDayTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalYearMonth", function() { return IntervalYearMonth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FixedSizeList", function() { return FixedSizeList; });
/* harmony import */ var _enum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enum */ "../tables/src/lib/types/arrow-like/enum.js");
// This code is adapted from ArrowJS https://github.com/apache/arrow
// under Apache license http://www.apache.org/licenses/LICENSE-2.0



class DataType {
  static isNull(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Null;
  }
  static isInt(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Int;
  }
  static isFloat(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Float;
  }
  static isBinary(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Binary;
  }
  static isUtf8(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Utf8;
  }
  static isBool(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Bool;
  }
  static isDecimal(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Decimal;
  }
  static isDate(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Date;
  }
  static isTime(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Time;
  }
  static isTimestamp(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Timestamp;
  }
  static isInterval(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Interval;
  }
  static isList(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].List;
  }
  static isStruct(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Struct;
  }
  static isUnion(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Union;
  }
  static isFixedSizeBinary(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].FixedSizeBinary;
  }
  static isFixedSizeList(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].FixedSizeList;
  }
  static isMap(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Map;
  }
  static isDictionary(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Dictionary;
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].NONE;
  }
  // get ArrayType() { return Array; }
  compareTo(other) {
    // TODO
    return this === other; // comparer.visit(this, other);
  }
}

// NULL

class Null extends DataType {
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Null;
  }
  get [Symbol.toStringTag]() {
    return 'Null';
  }
  toString() {
    return `Null`;
  }
}

// BOOLEANS

class Bool extends DataType {
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Bool;
  }
  get ArrayType() {
    return Uint8Array;
  }
  get [Symbol.toStringTag]() {
    return 'Bool';
  }
  toString() {
    return `Bool`;
  }
}

// INTS

class Int extends DataType {
  constructor(isSigned, bitWidth) {
    super();
    this.isSigned = isSigned;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Int;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? Int32Array : Uint32Array;
      default:
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
  }
  get [Symbol.toStringTag]() {
    return 'Int';
  }
  toString() {
    return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
  }
}

class Int8 extends Int {
  constructor() {
    super(true, 8);
  }
}
class Int16 extends Int {
  constructor() {
    super(true, 16);
  }
}
class Int32 extends Int {
  constructor() {
    super(true, 32);
  }
}
class Int64 extends Int {
  constructor() {
    super(true, 64);
  }
}
class Uint8 extends Int {
  constructor() {
    super(false, 8);
  }
}
class Uint16 extends Int {
  constructor() {
    super(false, 16);
  }
}
class Uint32 extends Int {
  constructor() {
    super(false, 32);
  }
}
class Uint64 extends Int {
  constructor() {
    super(false, 64);
  }
}

// FLOATS

const Precision = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};

class Float extends DataType {
  constructor(precision) {
    super();
    this.precision = precision;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Float;
  }
  get ArrayType() {
    switch (this.precision) {
      case Precision.HALF:
        return Uint16Array;
      case Precision.SINGLE:
        return Float32Array;
      case Precision.DOUBLE:
        return Float64Array;
      default:
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
  }
  get [Symbol.toStringTag]() {
    return 'Float';
  }
  toString() {
    return `Float${this.precision}`;
  }
}

class Float16 extends Float {
  constructor() {
    super(Precision.HALF);
  }
}
class Float32 extends Float {
  constructor() {
    super(Precision.SINGLE);
  }
}
class Float64 extends Float {
  constructor() {
    super(Precision.DOUBLE);
  }
}

// STRINGS

class Utf8 extends DataType {
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Utf8;
  }
  get ArrayType() {
    return Uint8Array;
  }
  get [Symbol.toStringTag]() {
    return 'Utf8';
  }
  toString() {
    return `Utf8`;
  }
}

// DATES, TIMES AND INTERVALS

const DateUnit = {
  DAY: 0,
  MILLISECOND: 1
};

class Date extends DataType {
  constructor(unit) {
    super();
    this.unit = unit;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Date;
  }
  get ArrayType() {
    return Int32Array;
  }
  get [Symbol.toStringTag]() {
    return 'Date';
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
  }
}

class DateDay extends Date {
  constructor() {
    super(DateUnit.DAY);
  }
}
class DateMillisecond extends Date {
  constructor() {
    super(DateUnit.MILLISECOND);
  }
}

const TimeUnit = {
  SECOND: 1,
  MILLISECOND: 1e3,
  MICROSECOND: 1e6,
  NANOSECOND: 1e9
};

class Time extends DataType {
  constructor(unit, bitWidth) {
    super();
    this.unit = unit;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Time;
  }
  toString() {
    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
  }
  get [Symbol.toStringTag]() {
    return 'Time';
  }
  get ArrayType() {
    return Int32Array;
  }
}

class TimeSecond extends Time {
  constructor() {
    super(TimeUnit.SECOND, 32);
  }
}
class TimeMillisecond extends Time {
  constructor() {
    super(TimeUnit.MILLISECOND, 32);
  }
}
// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }
// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }

class Timestamp extends DataType {
  constructor(unit, timezone = null) {
    super();
    this.unit = unit;
    this.timezone = timezone;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Timestamp;
  }
  get ArrayType() {
    return Int32Array;
  }
  get [Symbol.toStringTag]() {
    return 'Timestamp';
  }
  toString() {
    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
  }
}

class TimestampSecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.SECOND, timezone);
  }
}
class TimestampMillisecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.MILLISECOND, timezone);
  }
}
class TimestampMicrosecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.MICROSECOND, timezone);
  }
}
class TimestampNanosecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.NANOSECOND, timezone);
  }
}

const IntervalUnit = {
  DAY_TIME: 0,
  YEAR_MONTH: 1
};

class Interval extends DataType {
  constructor(unit) {
    super();
    this.unit = unit;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Interval;
  }
  get ArrayType() {
    return Int32Array;
  }
  get [Symbol.toStringTag]() {
    return 'Interval';
  }
  toString() {
    return `Interval<${IntervalUnit[this.unit]}>`;
  }
}

class IntervalDayTime extends Interval {
  constructor() {
    super(IntervalUnit.DAY_TIME);
  }
}
class IntervalYearMonth extends Interval {
  constructor() {
    super(IntervalUnit.YEAR_MONTH);
  }
}

class FixedSizeList extends DataType {
  constructor(listSize, child) {
    super();
    this.listSize = listSize;
    this.children = [child];
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  get [Symbol.toStringTag]() {
    return 'FixedSizeList';
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
}


/***/ }),

/***/ "../tables/src/lib/types/type-utils.js":
/*!*********************************************!*\
  !*** ../tables/src/lib/types/type-utils.js ***!
  \*********************************************/
/*! exports provided: getTypeInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypeInfo", function() { return getTypeInfo; });
/* harmony import */ var _arrow_like_enum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrow-like/enum */ "../tables/src/lib/types/arrow-like/enum.js");


function getTypeInfo(arrowTypeLike) {
  return {
    typeId: arrowTypeLike.typeId,
    ArrayType: arrowTypeLike.ArrayType,
    typeName: arrowTypeLike.toString(),
    typeEnumName: getTypeKey(arrowTypeLike.typeId),
    precision: arrowTypeLike.precision
  };
}

let ReverseType = null;

function getTypeKey(typeKey) {
  if (!ReverseType) {
    ReverseType = {};
    for (const key in _arrow_like_enum__WEBPACK_IMPORTED_MODULE_0__["Type"]) {
      ReverseType[_arrow_like_enum__WEBPACK_IMPORTED_MODULE_0__["Type"][key]] = key;
    }
  }

  return ReverseType[typeKey];
}


/***/ }),

/***/ "../tables/src/lib/utils/assert.js":
/*!*****************************************!*\
  !*** ../tables/src/lib/utils/assert.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../tables/src/lib/utils/async-queue.js":
/*!**********************************************!*\
  !*** ../tables/src/lib/utils/async-queue.js ***!
  \**********************************************/
/*! exports provided: takeAsync, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeAsync", function() { return takeAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AsyncQueue; });
// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license
// http://2ality.com/2016/10/asynchronous-iteration.html

class ArrayQueue extends Array {
  enqueue(value) {
    // Add at the end
    return this.push(value);
  }
  dequeue() {
    // Remove first element
    return this.shift();
  }
}

/**
 * @returns a Promise for an Array with the elements
 * in `asyncIterable`
 */
async function takeAsync(asyncIterable, count = Infinity) {
  const result = [];
  const iterator = asyncIterable[Symbol.asyncIterator]();
  while (result.length < count) {
    const {value, done} = await iterator.next();
    if (done) {
      break;
    }
    result.push(value);
  }
  return result;
}

class AsyncQueue {
  constructor() {
    // enqueues > dequeues
    this._values = new ArrayQueue();
    // dequeues > enqueues
    this._settlers = new ArrayQueue();
    this._closed = false;
  }

  close() {
    while (this._settlers.length > 0) {
      this._settlers.dequeue().resolve({done: true});
    }
    this._closed = true;
  }

  [Symbol.asyncIterator]() {
    return this;
  }

  enqueue(value) {
    if (this._closed) {
      throw new Error('Closed');
    }

    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error('Illegal internal state');
      }
      const settler = this._settlers.dequeue();
      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({value});
      }
    } else {
      this._values.enqueue(value);
    }
  }

  /**
   * @returns a Promise for an IteratorResult
   */
  next() {
    if (this._values.length > 0) {
      const value = this._values.dequeue();
      if (value instanceof Error) {
        return Promise.reject(value);
      }
      return Promise.resolve({value});
    }

    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error('Illegal internal state');
      }
      return Promise.resolve({done: true});
    }
    // Wait for new values to be enqueued
    return new Promise((resolve, reject) => {
      this._settlers.enqueue({resolve, reject});
    });
  }
}


/***/ }),

/***/ "../tables/src/lib/xml/parse-xml.js":
/*!******************************************!*\
  !*** ../tables/src/lib/xml/parse-xml.js ***!
  \******************************************/
/*! exports provided: default, parseXMLSupported */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseXML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseXMLSupported", function() { return parseXMLSupported; });
/* global window, DOMParser */
function parseXML(xml) {
  if (window.DOMParser) {
    const xmlDoc = new window.DOMParser().parseFromString(xml, 'application/xml');
    const parseError = isXMLParseError(xmlDoc);
    if (parseError) {
      throw new Error(parseError);
    }
    return xmlDoc;
  }

  if (typeof window.ActiveXObject !== 'undefined') {
    const xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
    if (xmlDoc) {
      xmlDoc.async = 'false';
      xmlDoc.loadXML(xml);
      return xmlDoc;
    }
  }

  throw new Error('No XML parser available');
}

function parseXMLSupported() {
  if (typeof window === 'undefined') {
    return false;
  }

  if (window.DOMParser) {
    return true;
  }

  if (typeof window.ActiveXObject !== 'undefined' && new window.ActiveXObject('Microsoft.XMLDOM')) {
    return true;
  }

  return false;
}

// https://stackoverflow.com/questions/11563554/how-do-i-detect-xml-parsing-errors-when-using-javascripts-domparser-in-a-cross
function isXMLParseError(parsedDocument) {
  const parser = new DOMParser();
  const erroneousParse = parser.parseFromString('<', 'text/xml');
  const parsererrorNS = erroneousParse.getElementsByTagName('parsererror')[0].namespaceURI;

  if (parsererrorNS === 'http://www.w3.org/1999/xhtml') {
    // In PhantomJS the parseerror element doesn't seem to have a special namespace,
    // so we are just guessing here :(
    const errorElements = parsedDocument.getElementsByTagName('parsererror');
    return errorElements.length ? errorElements[0].innerHTML : null;
  }

  return parsedDocument.getElementsByTagNameNS(parsererrorNS, 'parsererror').length > 0;
}


/***/ }),

/***/ "../tables/src/xml-loader.js":
/*!***********************************!*\
  !*** ../tables/src/xml-loader.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_xml_parse_xml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/xml/parse-xml */ "../tables/src/lib/xml/parse-xml.js");


const XML_HEADER = '<?xml';

function testText(text) {
  return text.startsWith(XML_HEADER);
}

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'KML',
  extensions: ['kml'],
  supported: Object(_lib_xml_parse_xml__WEBPACK_IMPORTED_MODULE_0__["parseXMLSupported"])(),
  testText,
  parseTextSync: _lib_xml_parse_xml__WEBPACK_IMPORTED_MODULE_0__["default"],
  browserOnly: true,
  worker: false
});


/***/ }),

/***/ "./src/bundle.js":
/*!***********************!*\
  !*** ./src/bundle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global window, global */
const moduleExports = __webpack_require__(/*! ./index */ "./src/index.js");
const _global = typeof window === 'undefined' ? global : window;
// @ts-ignore
_global.loaders = _global.loaders || {};
// @ts-ignore
module.exports = Object.assign(_global.loaders, moduleExports);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/geojson-loader.js":
/*!*******************************!*\
  !*** ./src/geojson-loader.js ***!
  \*******************************/
/*! exports provided: GeoJSONWorkerLoader, GeoJSONLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoJSONWorkerLoader", function() { return GeoJSONWorkerLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoJSONLoader", function() { return GeoJSONLoader; });
/* harmony import */ var _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/tables */ "../tables/src/index.js");
/* harmony import */ var _loaders_gl_gis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/gis */ "../gis/src/index.js");
/* harmony import */ var _lib_parse_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/parse-json */ "./src/lib/parse-json.js");
/* harmony import */ var _lib_parse_json_in_batches__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/parse-json-in-batches */ "./src/lib/parse-json-in-batches.js");
/* global TextDecoder */
/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */
/** @typedef {import('@loaders.gl/loader-utils').WorkerLoaderObject} WorkerLoaderObject */





// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.13" : undefined;

const GeoJSONLoaderOptions = {
  geojson: {
    TableBatch: _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_0__["RowTableBatch"],
    batchSize: 'auto',
    workerUrl: `https://unpkg.com/@loaders.gl/json@${VERSION}/dist/geojson-loader.worker.js`
  },
  json: {
    jsonpaths: ['$', '$.features']
  },
  gis: {
    format: 'geojson'
  }
};

/** @type {WorkerLoaderObject} */
const GeoJSONWorkerLoader = {
  id: 'geojson',
  name: 'GeoJSON',
  version: VERSION,
  extensions: ['geojson'],
  mimeTypes: ['application/geo+json'],
  // TODO - support various line based JSON formats
  /*
  extensions: {
    json: null,
    jsonl: {stream: true},
    ndjson: {stream: true}
  },
  mimeTypes: {
    'application/json': null,
    'application/json-seq': {stream: true},
    'application/x-ndjson': {stream: true}
  },
  */
  category: 'geometry',
  text: true,
  options: GeoJSONLoaderOptions
};

/** @type {LoaderObject} */
const GeoJSONLoader = {
  ...GeoJSONWorkerLoader,
  parse,
  parseTextSync,
  parseInBatches
};

async function parse(arrayBuffer, options) {
  return parseTextSync(new TextDecoder().decode(arrayBuffer), options);
}

function parseTextSync(text, options) {
  // Apps can call the parse method directly, we so apply default options here
  options = {...GeoJSONLoaderOptions, ...options};
  options.json = {...GeoJSONLoaderOptions.geojson, ...options.geojson};
  options.gis = options.gis || {};
  const json = Object(_lib_parse_json__WEBPACK_IMPORTED_MODULE_2__["default"])(text, options);
  switch (options.gis.format) {
    case 'binary':
      return Object(_loaders_gl_gis__WEBPACK_IMPORTED_MODULE_1__["geojsonToBinary"])(json);
    default:
      return json;
  }
}

async function parseInBatches(asyncIterator, options) {
  // Apps can call the parse method directly, we so apply default options here
  options = {...GeoJSONLoaderOptions, ...options};
  options.json = {...GeoJSONLoaderOptions.geojson, ...options.geojson};

  const geojsonIterator = Object(_lib_parse_json_in_batches__WEBPACK_IMPORTED_MODULE_3__["default"])(asyncIterator, options);

  switch (options.gis.format) {
    case 'binary':
      return makeBinaryGeometryIterator(geojsonIterator);
    default:
      return geojsonIterator;
  }
}

async function* makeBinaryGeometryIterator(geojsonIterator) {
  for await (const batch of geojsonIterator) {
    batch.data = Object(_loaders_gl_gis__WEBPACK_IMPORTED_MODULE_1__["geojsonToBinary"])(batch.data);
    yield batch;
  }
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: JSONLoader, _GeoJSONLoader, _GeoJSONWorkerLoader, _JSONPath, _ClarinetParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _json_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json-loader */ "./src/json-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return _json_loader__WEBPACK_IMPORTED_MODULE_0__["JSONLoader"]; });

/* harmony import */ var _geojson_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geojson-loader */ "./src/geojson-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_GeoJSONLoader", function() { return _geojson_loader__WEBPACK_IMPORTED_MODULE_1__["GeoJSONLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_GeoJSONWorkerLoader", function() { return _geojson_loader__WEBPACK_IMPORTED_MODULE_1__["GeoJSONWorkerLoader"]; });

/* harmony import */ var _lib_jsonpath_jsonpath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/jsonpath/jsonpath */ "./src/lib/jsonpath/jsonpath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_JSONPath", function() { return _lib_jsonpath_jsonpath__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _lib_clarinet_clarinet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/clarinet/clarinet */ "./src/lib/clarinet/clarinet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_ClarinetParser", function() { return _lib_clarinet_clarinet__WEBPACK_IMPORTED_MODULE_3__["default"]; });




// EXPERIMENTAL EXPORTS - WARNING: MAY BE REMOVED WIHTOUT NOTICE IN FUTURE RELEASES




/***/ }),

/***/ "./src/json-loader.js":
/*!****************************!*\
  !*** ./src/json-loader.js ***!
  \****************************/
/*! exports provided: JSONLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
/* harmony import */ var _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/tables */ "../tables/src/index.js");
/* harmony import */ var _lib_parse_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parse-json */ "./src/lib/parse-json.js");
/* harmony import */ var _lib_parse_json_in_batches__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/parse-json-in-batches */ "./src/lib/parse-json-in-batches.js");
/* global TextDecoder */



/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */

// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.13" : undefined;

const JSONLoaderOptions = {
  json: {
    TableBatch: _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_0__["RowTableBatch"],
    batchSize: 'auto',
    _rootObjectBatches: false,
    table: false,
    jsonpaths: []
  }
};

/** @type {LoaderObject} */
const JSONLoader = {
  id: 'json',
  name: 'JSON',
  version: VERSION,
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json'],
  // TODO - support various line based JSON formats
  /*
  extensions: {
    json: null,
    jsonl: {stream: true},
    ndjson: {stream: true}
  },
  mimeTypes: {
    'application/json': null,
    'application/json-seq': {stream: true},
    'application/x-ndjson': {stream: true}
  },
  */
  category: 'table',
  text: true,
  parse,
  parseTextSync,
  parseInBatches,
  options: JSONLoaderOptions,
  deprecatedOptions: {
    json: {
      _rootObjectBatches: 'metadata'
    }
  }
};

async function parse(arrayBuffer, options) {
  return parseTextSync(new TextDecoder().decode(arrayBuffer), options);
}

function parseTextSync(text, options) {
  // Apps can call the parse method directly, we so apply default options here
  options = {...JSONLoaderOptions, ...options};
  options.json = {...JSONLoaderOptions.json, ...options.json};
  return Object(_lib_parse_json__WEBPACK_IMPORTED_MODULE_1__["default"])(text, options);
}

async function parseInBatches(asyncIterator, options) {
  // Apps can call the parse method directly, we so apply default options here
  options = {...JSONLoaderOptions, ...options};
  options.json = {...JSONLoaderOptions.json, ...options.json};
  return Object(_lib_parse_json_in_batches__WEBPACK_IMPORTED_MODULE_2__["default"])(asyncIterator, options);
}


/***/ }),

/***/ "./src/lib/clarinet/clarinet.js":
/*!**************************************!*\
  !*** ./src/lib/clarinet/clarinet.js ***!
  \**************************************/
/*! exports provided: EVENTS, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EVENTS", function() { return EVENTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClarinetParser; });
/* eslint-disable */
// @ts-nocheck
const env = {};

const EVENTS = [
  'value',
  'string',
  'key',
  'openobject',
  'closeobject',
  'openarray',
  'closearray',
  'error',
  'end',
  'ready'
];

// Removes the MAX_BUFFER_LENGTH, originally set to 64 * 1024
const MAX_BUFFER_LENGTH = Number.MAX_SAFE_INTEGER;
const DEBUG = env.CDEBUG === 'debug';

const buffers = {
  textNode: undefined,
  numberNode: ''
};

let S = 0;

const STATE = {
  BEGIN: S++,
  VALUE: S++, // general stuff
  OPEN_OBJECT: S++, // {
  CLOSE_OBJECT: S++, // }
  OPEN_ARRAY: S++, // [
  CLOSE_ARRAY: S++, // ]
  TEXT_ESCAPE: S++, // \ stuff
  STRING: S++, // ""
  BACKSLASH: S++,
  END: S++, // No more stack
  OPEN_KEY: S++, // , "a"
  CLOSE_KEY: S++, // :
  TRUE: S++, // r
  TRUE2: S++, // u
  TRUE3: S++, // e
  FALSE: S++, // a
  FALSE2: S++, // l
  FALSE3: S++, // s
  FALSE4: S++, // e
  NULL: S++, // u
  NULL2: S++, // l
  NULL3: S++, // l
  NUMBER_DECIMAL_POINT: S++, // .
  NUMBER_DIGIT: S++ // [0-9]
};

for (var s_ in STATE) STATE[STATE[s_]] = s_;

// switcharoo
S = STATE;

const Char = {
  tab: 0x09, // \t
  lineFeed: 0x0a, // \n
  carriageReturn: 0x0d, // \r
  space: 0x20, // " "

  doubleQuote: 0x22, // "
  plus: 0x2b, // +
  comma: 0x2c, // ,
  minus: 0x2d, // -
  period: 0x2e, // .

  _0: 0x30, // 0
  _9: 0x39, // 9

  colon: 0x3a, // :

  E: 0x45, // E

  openBracket: 0x5b, // [
  backslash: 0x5c, // \
  closeBracket: 0x5d, // ]

  a: 0x61, // a
  b: 0x62, // b
  e: 0x65, // e
  f: 0x66, // f
  l: 0x6c, // l
  n: 0x6e, // n
  r: 0x72, // r
  s: 0x73, // s
  t: 0x74, // t
  u: 0x75, // u

  openBrace: 0x7b, // {
  closeBrace: 0x7d // }
};

function checkBufferLength(parser) {
  const maxAllowed = Math.max(MAX_BUFFER_LENGTH, 10);
  let maxActual = 0;

  for (var buffer in buffers) {
    var len = parser[buffer] === undefined ? 0 : parser[buffer].length;
    if (len > maxAllowed) {
      switch (buffer) {
        case 'text':
          closeText(parser);
          break;

        default:
          error(parser, 'Max buffer length exceeded: ' + buffer);
      }
    }
    maxActual = Math.max(maxActual, len);
  }
  parser.bufferCheckPosition = MAX_BUFFER_LENGTH - maxActual + parser.position;
}

var stringTokenPattern = /[\\"\n]/g;

class ClarinetParser {
  constructor(options = {}) {
    this._initialize(options);
  }

  _initialize(options) {
    this._clearBuffers(this);
    this.bufferCheckPosition = MAX_BUFFER_LENGTH;
    this.q = '';
    this.c = '';
    this.p = '';
    this.options = options || {};
    this.closed = false;
    this.closedRoot = false;
    this.sawRoot = false;
    this.tag = null;
    this.error = null;
    this.state = S.BEGIN;
    this.stack = new Array();
    // mostly just for error reporting
    this.position = this.column = 0;
    this.line = 1;
    this.slashed = false;
    this.unicodeI = 0;
    this.unicodeS = null;
    this.depth = 0;

    // install callbacks
    if ('onready' in options) {
      this.onready = options.onready;
    }

    if ('onopenobject' in options) {
      this.onopenobject = options.onopenobject;
    }

    if ('onkey' in options) {
      this.onkey = options.onkey;
    }

    if ('oncloseobject' in options) {
      this.oncloseobject = options.oncloseobject;
    }

    if ('onopenarray' in options) {
      this.onopenarray = options.onopenarray;
    }

    if ('onclosearray' in options) {
      this.onclosearray = options.onclosearray;
    }

    if ('onvalue' in options) {
      this.onvalue = options.onvalue;
    }

    if ('onerror' in options) {
      this.onerror = options.onerror;
    }

    if ('onend' in options) {
      this.onend = options.onend;
    }

    if ('onchunkparsed' in options) {
      this.onchunkparsed = options.onchunkparsed;
    }

    emit(this, 'onready');
  }

  _clearBuffers() {
    for (var buffer in buffers) {
      this[buffer] = buffers[buffer];
    }
  }

  end() {
    if (this.state !== S.VALUE || this.depth !== 0) error(this, 'Unexpected end');

    closeValue(this);
    this.c = '';
    this.closed = true;
    emit(this, 'onend');
    this._initialize(this.options);
    return this;
  }

  resume() {
    this.error = null;
    return this;
  }

  close() {
    return this.write(null);
  }

  write(chunk) {
    if (this.error) {
      throw this.error;
    }
    if (this.closed) {
      return error(this, 'Cannot write after close. Assign an onready handler.');
    }
    if (chunk === null) {
      return this.end();
    }
    var i = 0,
      c = chunk.charCodeAt(0),
      p = this.p;
    if (DEBUG) console.log('write -> [' + chunk + ']');
    while (c) {
      p = c;
      this.c = c = chunk.charCodeAt(i++);
      // if chunk doesnt have next, like streaming char by char
      // this way we need to check if previous is really previous
      // if not we need to reset to what the this says is the previous
      // from buffer
      if (p !== c) {
        this.p = p;
      } else {
        p = this.p;
      }

      if (!c) break;

      if (DEBUG) console.log(i, c, STATE[this.state]);
      this.position++;
      if (c === Char.lineFeed) {
        this.line++;
        this.column = 0;
      } else this.column++;

      switch (this.state) {
        case S.BEGIN:
          if (c === Char.openBrace) this.state = S.OPEN_OBJECT;
          else if (c === Char.openBracket) this.state = S.OPEN_ARRAY;
          else if (!isWhitespace(c)) {
            error(this, 'Non-whitespace before {[.');
          }
          continue;

        case S.OPEN_KEY:
        case S.OPEN_OBJECT:
          if (isWhitespace(c)) continue;
          if (this.state === S.OPEN_KEY) this.stack.push(S.CLOSE_KEY);
          else {
            if (c === Char.closeBrace) {
              emit(this, 'onopenobject');
              this.depth++;
              emit(this, 'oncloseobject');
              this.depth--;
              this.state = this.stack.pop() || S.VALUE;
              continue;
            } else this.stack.push(S.CLOSE_OBJECT);
          }
          if (c === Char.doubleQuote) this.state = S.STRING;
          else error(this, 'Malformed object key should start with "');
          continue;

        case S.CLOSE_KEY:
        case S.CLOSE_OBJECT:
          if (isWhitespace(c)) continue;
          var event = this.state === S.CLOSE_KEY ? 'key' : 'object';
          if (c === Char.colon) {
            if (this.state === S.CLOSE_OBJECT) {
              this.stack.push(S.CLOSE_OBJECT);
              closeValue(this, 'onopenobject');
              this.depth++;
            } else closeValue(this, 'onkey');
            this.state = S.VALUE;
          } else if (c === Char.closeBrace) {
            emitNode(this, 'oncloseobject');
            this.depth--;
            this.state = this.stack.pop() || S.VALUE;
          } else if (c === Char.comma) {
            if (this.state === S.CLOSE_OBJECT) this.stack.push(S.CLOSE_OBJECT);
            closeValue(this);
            this.state = S.OPEN_KEY;
          } else error(this, 'Bad object');
          continue;

        case S.OPEN_ARRAY: // after an array there always a value
        case S.VALUE:
          if (isWhitespace(c)) continue;
          if (this.state === S.OPEN_ARRAY) {
            emit(this, 'onopenarray');
            this.depth++;
            this.state = S.VALUE;
            if (c === Char.closeBracket) {
              emit(this, 'onclosearray');
              this.depth--;
              this.state = this.stack.pop() || S.VALUE;
              continue;
            } else {
              this.stack.push(S.CLOSE_ARRAY);
            }
          }
          if (c === Char.doubleQuote) this.state = S.STRING;
          else if (c === Char.openBrace) this.state = S.OPEN_OBJECT;
          else if (c === Char.openBracket) this.state = S.OPEN_ARRAY;
          else if (c === Char.t) this.state = S.TRUE;
          else if (c === Char.f) this.state = S.FALSE;
          else if (c === Char.n) this.state = S.NULL;
          else if (c === Char.minus) {
            // keep and continue
            this.numberNode += '-';
          } else if (Char._0 <= c && c <= Char._9) {
            this.numberNode += String.fromCharCode(c);
            this.state = S.NUMBER_DIGIT;
          } else error(this, 'Bad value');
          continue;

        case S.CLOSE_ARRAY:
          if (c === Char.comma) {
            this.stack.push(S.CLOSE_ARRAY);
            closeValue(this, 'onvalue');
            this.state = S.VALUE;
          } else if (c === Char.closeBracket) {
            emitNode(this, 'onclosearray');
            this.depth--;
            this.state = this.stack.pop() || S.VALUE;
          } else if (isWhitespace(c)) continue;
          else error(this, 'Bad array');
          continue;

        case S.STRING:
          if (this.textNode === undefined) {
            this.textNode = '';
          }

          // thanks thejh, this is an about 50% performance improvement.
          var starti = i - 1,
            slashed = this.slashed,
            unicodeI = this.unicodeI;
          STRING_BIGLOOP: while (true) {
            if (DEBUG) console.log(i, c, STATE[this.state], slashed);
            // zero means "no unicode active". 1-4 mean "parse some more". end after 4.
            while (unicodeI > 0) {
              this.unicodeS += String.fromCharCode(c);
              c = chunk.charCodeAt(i++);
              this.position++;
              if (unicodeI === 4) {
                // TODO this might be slow? well, probably not used too often anyway
                this.textNode += String.fromCharCode(parseInt(this.unicodeS, 16));
                unicodeI = 0;
                starti = i - 1;
              } else {
                unicodeI++;
              }
              // we can just break here: no stuff we skipped that still has to be sliced out or so
              if (!c) break STRING_BIGLOOP;
            }
            if (c === Char.doubleQuote && !slashed) {
              this.state = this.stack.pop() || S.VALUE;
              this.textNode += chunk.substring(starti, i - 1);
              this.position += i - 1 - starti;
              break;
            }
            if (c === Char.backslash && !slashed) {
              slashed = true;
              this.textNode += chunk.substring(starti, i - 1);
              this.position += i - 1 - starti;
              c = chunk.charCodeAt(i++);
              this.position++;
              if (!c) break;
            }
            if (slashed) {
              slashed = false;
              if (c === Char.n) {
                this.textNode += '\n';
              } else if (c === Char.r) {
                this.textNode += '\r';
              } else if (c === Char.t) {
                this.textNode += '\t';
              } else if (c === Char.f) {
                this.textNode += '\f';
              } else if (c === Char.b) {
                this.textNode += '\b';
              } else if (c === Char.u) {
                // \uxxxx. meh!
                unicodeI = 1;
                this.unicodeS = '';
              } else {
                this.textNode += String.fromCharCode(c);
              }
              c = chunk.charCodeAt(i++);
              this.position++;
              starti = i - 1;
              if (!c) break;
              else continue;
            }

            stringTokenPattern.lastIndex = i;
            var reResult = stringTokenPattern.exec(chunk);
            if (reResult === null) {
              i = chunk.length + 1;
              this.textNode += chunk.substring(starti, i - 1);
              this.position += i - 1 - starti;
              break;
            }
            i = reResult.index + 1;
            c = chunk.charCodeAt(reResult.index);
            if (!c) {
              this.textNode += chunk.substring(starti, i - 1);
              this.position += i - 1 - starti;
              break;
            }
          }
          this.slashed = slashed;
          this.unicodeI = unicodeI;
          continue;

        case S.TRUE:
          if (c === Char.r) this.state = S.TRUE2;
          else error(this, 'Invalid true started with t' + c);
          continue;

        case S.TRUE2:
          if (c === Char.u) this.state = S.TRUE3;
          else error(this, 'Invalid true started with tr' + c);
          continue;

        case S.TRUE3:
          if (c === Char.e) {
            emit(this, 'onvalue', true);
            this.state = this.stack.pop() || S.VALUE;
          } else error(this, 'Invalid true started with tru' + c);
          continue;

        case S.FALSE:
          if (c === Char.a) this.state = S.FALSE2;
          else error(this, 'Invalid false started with f' + c);
          continue;

        case S.FALSE2:
          if (c === Char.l) this.state = S.FALSE3;
          else error(this, 'Invalid false started with fa' + c);
          continue;

        case S.FALSE3:
          if (c === Char.s) this.state = S.FALSE4;
          else error(this, 'Invalid false started with fal' + c);
          continue;

        case S.FALSE4:
          if (c === Char.e) {
            emit(this, 'onvalue', false);
            this.state = this.stack.pop() || S.VALUE;
          } else error(this, 'Invalid false started with fals' + c);
          continue;

        case S.NULL:
          if (c === Char.u) this.state = S.NULL2;
          else error(this, 'Invalid null started with n' + c);
          continue;

        case S.NULL2:
          if (c === Char.l) this.state = S.NULL3;
          else error(this, 'Invalid null started with nu' + c);
          continue;

        case S.NULL3:
          if (c === Char.l) {
            emit(this, 'onvalue', null);
            this.state = this.stack.pop() || S.VALUE;
          } else error(this, 'Invalid null started with nul' + c);
          continue;

        case S.NUMBER_DECIMAL_POINT:
          if (c === Char.period) {
            this.numberNode += '.';
            this.state = S.NUMBER_DIGIT;
          } else error(this, 'Leading zero not followed by .');
          continue;

        case S.NUMBER_DIGIT:
          if (Char._0 <= c && c <= Char._9) this.numberNode += String.fromCharCode(c);
          else if (c === Char.period) {
            if (this.numberNode.indexOf('.') !== -1) error(this, 'Invalid number has two dots');
            this.numberNode += '.';
          } else if (c === Char.e || c === Char.E) {
            if (this.numberNode.indexOf('e') !== -1 || this.numberNode.indexOf('E') !== -1)
              error(this, 'Invalid number has two exponential');
            this.numberNode += 'e';
          } else if (c === Char.plus || c === Char.minus) {
            if (!(p === Char.e || p === Char.E)) error(this, 'Invalid symbol in number');
            this.numberNode += String.fromCharCode(c);
          } else {
            closeNumber(this);
            i--; // go back one
            this.state = this.stack.pop() || S.VALUE;
          }
          continue;

        default:
          error(this, 'Unknown state: ' + this.state);
      }
    }
    if (this.position >= this.bufferCheckPosition) {
      checkBufferLength(this);
    }

    emit(this, 'onchunkparsed');

    return this;
  }
}

function emit(parser, event, data) {
  if (DEBUG) {
    console.log('-- emit', event, data);
  }
  if (parser[event]) {
    parser[event](data, parser);
  }
}

function emitNode(parser, event, data) {
  closeValue(parser);
  emit(parser, event, data);
}

function closeValue(parser, event) {
  parser.textNode = textopts(parser.options, parser.textNode);
  if (parser.textNode !== undefined) {
    emit(parser, event ? event : 'onvalue', parser.textNode);
  }
  parser.textNode = undefined;
}

function closeNumber(parser) {
  if (parser.numberNode) emit(parser, 'onvalue', parseFloat(parser.numberNode));
  parser.numberNode = '';
}

function textopts(opt, text) {
  if (text === undefined) {
    return text;
  }
  if (opt.trim) text = text.trim();
  if (opt.normalize) text = text.replace(/\s+/g, ' ');
  return text;
}

function error(parser, er) {
  closeValue(parser);
  er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
  er = new Error(er);
  parser.error = er;
  emit(parser, 'onerror', er);
  return parser;
}

function isWhitespace(c) {
  return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;
}


/***/ }),

/***/ "./src/lib/jsonpath/jsonpath.js":
/*!**************************************!*\
  !*** ./src/lib/jsonpath/jsonpath.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JSONPath; });
/**
 * A parser for a minimal subset of the jsonpath standard
 * Full JSON path parsers for JS exist but are quite large (bundle size)
 *
 * Supports
 *
 *   `$.component.component.component`
 */
class JSONPath {
  constructor(path = null) {
    this.path = ['$'];

    if (path instanceof JSONPath) {
      this.path = [...path.path];
      return;
    }

    if (Array.isArray(path)) {
      this.path.push(...path);
      return;
    }

    // Parse a string as a JSONPath
    if (typeof path === 'string') {
      this.path = path.split('.');
      if (this.path[0] !== '$') {
        throw new Error('JSONPaths must start with $');
      }
    }
  }

  clone() {
    return new JSONPath(this);
  }

  toString() {
    return this.path.join('.');
  }

  push(name) {
    this.path.push(name);
  }

  pop() {
    return this.path.pop();
  }

  set(name) {
    this.path[this.path.length - 1] = name;
  }

  equals(other) {
    if (!this || !other || this.path.length !== other.path.length) {
      return false;
    }

    for (let i = 0; i < this.path.length; ++i) {
      if (this.path[i] !== other.path[i]) {
        return false;
      }
    }

    return true;
  }

  /**
   * Sets the value pointed at by path
   * TODO - handle root path
   * @param {*} object
   * @param {*} value
   */
  setFieldAtPath(object, value) {
    const path = [...this.path];
    path.shift();
    const field = path.pop();
    for (const component of path) {
      object = object[component];
    }
    object[field] = value;
  }

  /**
   * Gets the value pointed at by path
   * TODO - handle root path
   * @param {*} object
   */
  getFieldAtPath(object) {
    const path = [...this.path];
    path.shift();
    const field = path.pop();
    for (const component of path) {
      object = object[component];
    }
    return object[field];
  }
}


/***/ }),

/***/ "./src/lib/parse-json-in-batches.js":
/*!******************************************!*\
  !*** ./src/lib/parse-json-in-batches.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseJSONInBatches; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/tables */ "../tables/src/index.js");
/* harmony import */ var _parser_streaming_json_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser/streaming-json-parser */ "./src/lib/parser/streaming-json-parser.js");




// TODO - support batch size 0 = no batching/single batch?
// eslint-disable-next-line max-statements, complexity
async function* parseJSONInBatches(asyncIterator, options) {
  asyncIterator = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["makeTextDecoderIterator"])(asyncIterator);

  const {metadata} = options;
  const {batchSize, _rootObjectBatches, jsonpaths} = options.json;
  const TableBatchType = options.json.TableBatch;

  let isFirstChunk = true;
  let tableBatchBuilder = null;
  let schema = null;

  const parser = new _parser_streaming_json_parser__WEBPACK_IMPORTED_MODULE_2__["default"]({jsonpaths});
  tableBatchBuilder =
    // @ts-ignore
    tableBatchBuilder || new _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_1__["TableBatchBuilder"](TableBatchType, schema, {batchSize});

  for await (const chunk of asyncIterator) {
    const rows = parser.write(chunk);

    const jsonpath = rows.length > 0 && parser.getStreamingJsonPathAsString();

    if (rows.length > 0 && isFirstChunk) {
      if (metadata) {
        const initialBatch = {
          batchType: 'partial-result',
          container: parser.getPartialResult(),
          data: [],
          bytesUsed: 0,
          schema: null,
          jsonpath
        };
        yield initialBatch;
      }
      // Backwards compabitility
      if (_rootObjectBatches) {
        const initialBatch = {
          batchType: 'root-object-batch-partial',
          container: parser.getPartialResult(),
          data: [],
          schema: null
        };
        yield initialBatch;
      }
      isFirstChunk = false;
      schema = deduceSchema(rows);
    }

    // Add the row
    for (const row of rows) {
      tableBatchBuilder.addRow(row);
      // If a batch has been completed, emit it
      if (tableBatchBuilder.isFull()) {
        yield tableBatchBuilder.getBatch({jsonpath});
      }
    }

    tableBatchBuilder.chunkComplete(chunk);
    if (tableBatchBuilder.isFull()) {
      yield tableBatchBuilder.getBatch({jsonpath});
    }
  }

  // yield final batch
  const jsonpath = parser.getStreamingJsonPathAsString();
  const batch = tableBatchBuilder.getBatch({jsonpath});
  if (batch) {
    yield batch;
  }

  if (metadata) {
    const finalBatch = {
      batchType: 'final-result',
      container: parser.getPartialResult(),
      jsonpath: parser.getStreamingJsonPathAsString(),
      data: [],
      schema: null
    };
    yield finalBatch;
  }
  if (_rootObjectBatches) {
    const finalBatch = {
      batchType: 'root-object-batch-complete',
      container: parser.getPartialResult(),
      data: [],
      schema: null
    };
    yield finalBatch;
  }
}

function deduceSchema(rows) {
  const row = rows[0];

  const schema = {};
  let i = 0;
  for (const columnName in row) {
    const value = row[columnName];
    switch (typeof value) {
      case 'number':
      case 'boolean':
        // TODO - booleans could be handled differently...
        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};
        break;

      case 'object':
        schema[columnName] = {name: String(columnName), index: i, type: Array};
        break;

      case 'string':
      default:
        schema[columnName] = {name: String(columnName), index: i, type: Array};
      // We currently only handle numeric rows
      // TODO we could offer a function to map strings to numbers?
    }
    i++;
  }
  return schema;
}


/***/ }),

/***/ "./src/lib/parse-json.js":
/*!*******************************!*\
  !*** ./src/lib/parse-json.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseJSONSync; });
function parseJSONSync(jsonText, options) {
  try {
    const json = JSON.parse(jsonText);
    if (options.json.table) {
      return getFirstArray(json) || json;
    }
    return json;
  } catch (error) {
    throw new Error('JSONLoader: failed to parse JSON');
  }
}

function getFirstArray(json) {
  if (Array.isArray(json)) {
    return json;
  }
  if (json && typeof json === 'object') {
    for (const value of Object.values(json)) {
      const array = getFirstArray(value);
      if (array) {
        return array;
      }
    }
  }
  return null;
}


/***/ }),

/***/ "./src/lib/parser/json-parser.js":
/*!***************************************!*\
  !*** ./src/lib/parser/json-parser.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JSONParser; });
/* harmony import */ var _clarinet_clarinet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clarinet/clarinet */ "./src/lib/clarinet/clarinet.js");
/* harmony import */ var _jsonpath_jsonpath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jsonpath/jsonpath */ "./src/lib/jsonpath/jsonpath.js");
// @ts-nocheck




// JSONParser builds a JSON object using the events emitted by the Clarinet parser

class JSONParser {
  constructor() {
    this.reset();
    this._initializeParser();
  }

  reset() {
    this.result = undefined;
    this.previousStates = [];
    this.currentState = Object.freeze({container: [], key: null});
    this.jsonpath = new _jsonpath_jsonpath__WEBPACK_IMPORTED_MODULE_1__["default"]();
  }

  write(chunk) {
    this.parser.write(chunk);
  }

  close() {
    this.parser.close();
  }

  // PRIVATE METHODS

  _pushOrSet(value) {
    const {container, key} = this.currentState;
    if (key !== null) {
      container[key] = value;
      this.currentState.key = null;
    } else {
      container.push(value);
    }
  }

  _openArray(newContainer = []) {
    this.jsonpath.push(null);
    this._pushOrSet(newContainer);
    this.previousStates.push(this.currentState);
    this.currentState = {container: newContainer, isArray: true, key: null};
  }

  _closeArray() {
    this.jsonpath.pop();
    this.currentState = this.previousStates.pop();
  }

  _openObject(newContainer = {}) {
    this.jsonpath.push(null);
    this._pushOrSet(newContainer);
    this.previousStates.push(this.currentState);
    this.currentState = {container: newContainer, isArray: false, key: null};
  }

  _closeObject() {
    this.jsonpath.pop();
    this.currentState = this.previousStates.pop();
  }

  _initializeParser() {
    this.parser = new _clarinet_clarinet__WEBPACK_IMPORTED_MODULE_0__["default"]({
      onready: () => {
        this.jsonpath = new _jsonpath_jsonpath__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.previousStates.length = 0;
        this.currentState.container.length = 0;
      },

      onopenobject: name => {
        this._openObject({});
        if (typeof name !== 'undefined') {
          this.parser.onkey(name);
        }
      },

      onkey: name => {
        this.jsonpath.set(name);
        this.currentState.key = name;
      },

      oncloseobject: () => {
        this._closeObject();
      },

      onopenarray: () => {
        this._openArray();
      },

      onclosearray: () => {
        this._closeArray();
      },

      onvalue: value => {
        this._pushOrSet(value);
      },

      onerror: error => {
        throw error;
      },

      onend: () => {
        this.result = this.currentState.container.pop();
      }
    });
  }
}


/***/ }),

/***/ "./src/lib/parser/streaming-json-parser.js":
/*!*************************************************!*\
  !*** ./src/lib/parser/streaming-json-parser.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StreamingJSONParser; });
/* harmony import */ var _json_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json-parser */ "./src/lib/parser/json-parser.js");
/* harmony import */ var _jsonpath_jsonpath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jsonpath/jsonpath */ "./src/lib/jsonpath/jsonpath.js");



/**
 * The `StreamingJSONParser` looks for the first array in the JSON structure.
 * and emits an array of chunks
 */
class StreamingJSONParser extends _json_parser__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(options = {}) {
    super();
    const jsonpaths = options.jsonpaths || [];
    this.jsonPaths = jsonpaths.map(jsonpath => new _jsonpath_jsonpath__WEBPACK_IMPORTED_MODULE_1__["default"](jsonpath));
    this.streamingJsonPath = null;
    this.streamingArray = null;
    this.topLevelObject = null;
    this._extendParser();
  }

  /**
   * write REDEFINITION
   * - super.write() chunk to parser
   * - get the contents (so far) of "topmost-level" array as batch of rows
   * - clear top-level array
   * - return the batch of rows\
   */
  write(chunk) {
    super.write(chunk);
    let array = [];
    if (this.streamingArray) {
      array = [...this.streamingArray];
      this.streamingArray.length = 0;
    }
    return array;
  }

  /**
   * Returns a partially formed result object
   * Useful for returning the "wrapper" object when array is not top level
   * e.g. GeoJSON
   */
  getPartialResult() {
    return this.topLevelObject;
  }

  getStreamingJsonPath() {
    return this.streamingJsonPath;
  }

  getStreamingJsonPathAsString() {
    return this.streamingJsonPath && this.streamingJsonPath.toString();
  }

  getJsonPath() {
    return this.jsonpath;
  }

  // PRIVATE METHODS

  /**
   * Checks is this.getJsonPath matches the jsonpaths provided in options
   */
  _matchJSONPath() {
    const currentPath = this.getJsonPath();
    // console.debug(`Testing JSONPath`, currentPath);

    // Backwards compatibility, match any array
    // TODO implement using wildcard once that is supported
    if (this.jsonPaths.length === 0) {
      return true;
    }

    for (const jsonPath of this.jsonPaths) {
      if (jsonPath.equals(currentPath)) {
        return true;
      }
    }

    return false;
  }

  _extendParser() {
    // Redefine onopenarray to locate and inject value for top-level array
    this.parser.onopenarray = () => {
      if (!this.streamingArray) {
        if (this._matchJSONPath()) {
          // @ts-ignore
          this.streamingJsonPath = this.getJsonPath().clone();
          this.streamingArray = [];
          this._openArray(this.streamingArray);
          return;
        }
      }

      this._openArray();
    };

    // Redefine onopenarray to inject value for top-level object
    this.parser.onopenobject = name => {
      if (!this.topLevelObject) {
        this.topLevelObject = {};
        this._openObject(this.topLevelObject);
      } else {
        this._openObject({});
      }
      if (typeof name !== 'undefined') {
        this.parser.onkey(name);
      }
    };
  }
}


/***/ }),

/***/ 0:
/*!********************************************!*\
  !*** ../node/require-utils.node (ignored) ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!*******************************************!*\
  !*** ../node/buffer-utils.node (ignored) ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});