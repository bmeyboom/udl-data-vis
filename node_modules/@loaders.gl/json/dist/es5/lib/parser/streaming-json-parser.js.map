{"version":3,"sources":["../../../../src/lib/parser/streaming-json-parser.js"],"names":["StreamingJSONParser","options","jsonpaths","jsonPaths","map","jsonpath","JSONPath","streamingJsonPath","streamingArray","topLevelObject","_extendParser","chunk","array","length","toString","currentPath","getJsonPath","jsonPath","equals","parser","onopenarray","_matchJSONPath","clone","_openArray","onopenobject","name","_openObject","onkey","JSONParser"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;;;;;;;;;;;IAMqBA,mB;;;;;AACnB,iCAA0B;AAAA;;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAAA;AACxB;AACA,QAAMC,SAAS,GAAGD,OAAO,CAACC,SAAR,IAAqB,EAAvC;AACA,UAAKC,SAAL,GAAiBD,SAAS,CAACE,GAAV,CAAc,UAAAC,QAAQ;AAAA,aAAI,IAAIC,oBAAJ,CAAaD,QAAb,CAAJ;AAAA,KAAtB,CAAjB;AACA,UAAKE,iBAAL,GAAyB,IAAzB;AACA,UAAKC,cAAL,GAAsB,IAAtB;AACA,UAAKC,cAAL,GAAsB,IAAtB;;AACA,UAAKC,aAAL;;AAPwB;AAQzB;;;;0BASKC,K,EAAO;AACX,uHAAYA,KAAZ;AACA,UAAIC,KAAK,GAAG,EAAZ;;AACA,UAAI,KAAKJ,cAAT,EAAyB;AACvBI,QAAAA,KAAK,uCAAO,KAAKJ,cAAZ,CAAL;AACA,aAAKA,cAAL,CAAoBK,MAApB,GAA6B,CAA7B;AACD;;AACD,aAAOD,KAAP;AACD;;;uCAOkB;AACjB,aAAO,KAAKH,cAAZ;AACD;;;2CAEsB;AACrB,aAAO,KAAKF,iBAAZ;AACD;;;mDAE8B;AAC7B,aAAO,KAAKA,iBAAL,IAA0B,KAAKA,iBAAL,CAAuBO,QAAvB,EAAjC;AACD;;;kCAEa;AACZ,aAAO,KAAKT,QAAZ;AACD;;;qCAOgB;AACf,UAAMU,WAAW,GAAG,KAAKC,WAAL,EAApB;;AAKA,UAAI,KAAKb,SAAL,CAAeU,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,eAAO,IAAP;AACD;;AARc,iDAUQ,KAAKV,SAVb;AAAA;;AAAA;AAUf,4DAAuC;AAAA,cAA5Bc,QAA4B;;AACrC,cAAIA,QAAQ,CAACC,MAAT,CAAgBH,WAAhB,CAAJ,EAAkC;AAChC,mBAAO,IAAP;AACD;AACF;AAdc;AAAA;AAAA;AAAA;AAAA;;AAgBf,aAAO,KAAP;AACD;;;oCAEe;AAAA;;AAEd,WAAKI,MAAL,CAAYC,WAAZ,GAA0B,YAAM;AAC9B,YAAI,CAAC,MAAI,CAACZ,cAAV,EAA0B;AACxB,cAAI,MAAI,CAACa,cAAL,EAAJ,EAA2B;AAEzB,YAAA,MAAI,CAACd,iBAAL,GAAyB,MAAI,CAACS,WAAL,GAAmBM,KAAnB,EAAzB;AACA,YAAA,MAAI,CAACd,cAAL,GAAsB,EAAtB;;AACA,YAAA,MAAI,CAACe,UAAL,CAAgB,MAAI,CAACf,cAArB;;AACA;AACD;AACF;;AAED,QAAA,MAAI,CAACe,UAAL;AACD,OAZD;;AAeA,WAAKJ,MAAL,CAAYK,YAAZ,GAA2B,UAAAC,IAAI,EAAI;AACjC,YAAI,CAAC,MAAI,CAAChB,cAAV,EAA0B;AACxB,UAAA,MAAI,CAACA,cAAL,GAAsB,EAAtB;;AACA,UAAA,MAAI,CAACiB,WAAL,CAAiB,MAAI,CAACjB,cAAtB;AACD,SAHD,MAGO;AACL,UAAA,MAAI,CAACiB,WAAL,CAAiB,EAAjB;AACD;;AACD,YAAI,OAAOD,IAAP,KAAgB,WAApB,EAAiC;AAC/B,UAAA,MAAI,CAACN,MAAL,CAAYQ,KAAZ,CAAkBF,IAAlB;AACD;AACF,OAVD;AAWD;;;EArG8CG,sB","sourcesContent":["import {default as JSONParser} from './json-parser';\nimport JSONPath from '../jsonpath/jsonpath';\n\n/**\n * The `StreamingJSONParser` looks for the first array in the JSON structure.\n * and emits an array of chunks\n */\nexport default class StreamingJSONParser extends JSONParser {\n  constructor(options = {}) {\n    super();\n    const jsonpaths = options.jsonpaths || [];\n    this.jsonPaths = jsonpaths.map(jsonpath => new JSONPath(jsonpath));\n    this.streamingJsonPath = null;\n    this.streamingArray = null;\n    this.topLevelObject = null;\n    this._extendParser();\n  }\n\n  /**\n   * write REDEFINITION\n   * - super.write() chunk to parser\n   * - get the contents (so far) of \"topmost-level\" array as batch of rows\n   * - clear top-level array\n   * - return the batch of rows\\\n   */\n  write(chunk) {\n    super.write(chunk);\n    let array = [];\n    if (this.streamingArray) {\n      array = [...this.streamingArray];\n      this.streamingArray.length = 0;\n    }\n    return array;\n  }\n\n  /**\n   * Returns a partially formed result object\n   * Useful for returning the \"wrapper\" object when array is not top level\n   * e.g. GeoJSON\n   */\n  getPartialResult() {\n    return this.topLevelObject;\n  }\n\n  getStreamingJsonPath() {\n    return this.streamingJsonPath;\n  }\n\n  getStreamingJsonPathAsString() {\n    return this.streamingJsonPath && this.streamingJsonPath.toString();\n  }\n\n  getJsonPath() {\n    return this.jsonpath;\n  }\n\n  // PRIVATE METHODS\n\n  /**\n   * Checks is this.getJsonPath matches the jsonpaths provided in options\n   */\n  _matchJSONPath() {\n    const currentPath = this.getJsonPath();\n    // console.debug(`Testing JSONPath`, currentPath);\n\n    // Backwards compatibility, match any array\n    // TODO implement using wildcard once that is supported\n    if (this.jsonPaths.length === 0) {\n      return true;\n    }\n\n    for (const jsonPath of this.jsonPaths) {\n      if (jsonPath.equals(currentPath)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _extendParser() {\n    // Redefine onopenarray to locate and inject value for top-level array\n    this.parser.onopenarray = () => {\n      if (!this.streamingArray) {\n        if (this._matchJSONPath()) {\n          // @ts-ignore\n          this.streamingJsonPath = this.getJsonPath().clone();\n          this.streamingArray = [];\n          this._openArray(this.streamingArray);\n          return;\n        }\n      }\n\n      this._openArray();\n    };\n\n    // Redefine onopenarray to inject value for top-level object\n    this.parser.onopenobject = name => {\n      if (!this.topLevelObject) {\n        this.topLevelObject = {};\n        this._openObject(this.topLevelObject);\n      } else {\n        this._openObject({});\n      }\n      if (typeof name !== 'undefined') {\n        this.parser.onkey(name);\n      }\n    };\n  }\n}\n"],"file":"streaming-json-parser.js"}