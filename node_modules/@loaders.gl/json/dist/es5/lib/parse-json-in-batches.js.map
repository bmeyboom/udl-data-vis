{"version":3,"sources":["../../../src/lib/parse-json-in-batches.js"],"names":["parseJSONInBatches","asyncIterator","options","metadata","json","batchSize","_rootObjectBatches","jsonpaths","TableBatchType","TableBatch","isFirstChunk","tableBatchBuilder","schema","parser","StreamingJSONParser","TableBatchBuilder","chunk","rows","write","jsonpath","length","getStreamingJsonPathAsString","initialBatch","batchType","container","getPartialResult","data","bytesUsed","deduceSchema","row","addRow","isFull","getBatch","chunkComplete","batch","finalBatch","i","columnName","value","name","String","index","type","Float32Array","Array"],"mappings":"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","sourcesContent":["import {makeTextDecoderIterator} from '@loaders.gl/loader-utils';\nimport {TableBatchBuilder} from '@loaders.gl/tables';\nimport StreamingJSONParser from './parser/streaming-json-parser';\n\n// TODO - support batch size 0 = no batching/single batch?\n// eslint-disable-next-line max-statements, complexity\nexport default async function* parseJSONInBatches(asyncIterator, options) {\n  asyncIterator = makeTextDecoderIterator(asyncIterator);\n\n  const {metadata} = options;\n  const {batchSize, _rootObjectBatches, jsonpaths} = options.json;\n  const TableBatchType = options.json.TableBatch;\n\n  let isFirstChunk = true;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const parser = new StreamingJSONParser({jsonpaths});\n  tableBatchBuilder =\n    // @ts-ignore\n    tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, {batchSize});\n\n  for await (const chunk of asyncIterator) {\n    const rows = parser.write(chunk);\n\n    const jsonpath = rows.length > 0 && parser.getStreamingJsonPathAsString();\n\n    if (rows.length > 0 && isFirstChunk) {\n      if (metadata) {\n        const initialBatch = {\n          batchType: 'partial-result',\n          container: parser.getPartialResult(),\n          data: [],\n          bytesUsed: 0,\n          schema: null,\n          jsonpath\n        };\n        yield initialBatch;\n      }\n      // Backwards compabitility\n      if (_rootObjectBatches) {\n        const initialBatch = {\n          batchType: 'root-object-batch-partial',\n          container: parser.getPartialResult(),\n          data: [],\n          schema: null\n        };\n        yield initialBatch;\n      }\n      isFirstChunk = false;\n      schema = deduceSchema(rows);\n    }\n\n    // Add the row\n    for (const row of rows) {\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        yield tableBatchBuilder.getBatch({jsonpath});\n      }\n    }\n\n    tableBatchBuilder.chunkComplete(chunk);\n    if (tableBatchBuilder.isFull()) {\n      yield tableBatchBuilder.getBatch({jsonpath});\n    }\n  }\n\n  // yield final batch\n  const jsonpath = parser.getStreamingJsonPathAsString();\n  const batch = tableBatchBuilder.getBatch({jsonpath});\n  if (batch) {\n    yield batch;\n  }\n\n  if (metadata) {\n    const finalBatch = {\n      batchType: 'final-result',\n      container: parser.getPartialResult(),\n      jsonpath: parser.getStreamingJsonPathAsString(),\n      data: [],\n      schema: null\n    };\n    yield finalBatch;\n  }\n  if (_rootObjectBatches) {\n    const finalBatch = {\n      batchType: 'root-object-batch-complete',\n      container: parser.getPartialResult(),\n      data: [],\n      schema: null\n    };\n    yield finalBatch;\n  }\n}\n\nfunction deduceSchema(rows) {\n  const row = rows[0];\n\n  const schema = {};\n  let i = 0;\n  for (const columnName in row) {\n    const value = row[columnName];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n\n      case 'object':\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n    i++;\n  }\n  return schema;\n}\n"],"file":"parse-json-in-batches.js"}