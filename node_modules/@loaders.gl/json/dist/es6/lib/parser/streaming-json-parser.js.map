{"version":3,"sources":["../../../../src/lib/parser/streaming-json-parser.js"],"names":["default","JSONParser","JSONPath","StreamingJSONParser","constructor","options","jsonpaths","jsonPaths","map","jsonpath","streamingJsonPath","streamingArray","topLevelObject","_extendParser","write","chunk","array","length","getPartialResult","getStreamingJsonPath","getStreamingJsonPathAsString","toString","getJsonPath","_matchJSONPath","currentPath","jsonPath","equals","parser","onopenarray","clone","_openArray","onopenobject","name","_openObject","onkey"],"mappings":"AAAA,SAAQA,OAAO,IAAIC,UAAnB,QAAoC,eAApC;AACA,OAAOC,QAAP,MAAqB,sBAArB;AAMA,eAAe,MAAMC,mBAAN,SAAkCF,UAAlC,CAA6C;AAC1DG,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACxB;AACA,UAAMC,SAAS,GAAGD,OAAO,CAACC,SAAR,IAAqB,EAAvC;AACA,SAAKC,SAAL,GAAiBD,SAAS,CAACE,GAAV,CAAcC,QAAQ,IAAI,IAAIP,QAAJ,CAAaO,QAAb,CAA1B,CAAjB;AACA,SAAKC,iBAAL,GAAyB,IAAzB;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA,SAAKC,cAAL,GAAsB,IAAtB;;AACA,SAAKC,aAAL;AACD;;AASDC,EAAAA,KAAK,CAACC,KAAD,EAAQ;AACX,UAAMD,KAAN,CAAYC,KAAZ;AACA,QAAIC,KAAK,GAAG,EAAZ;;AACA,QAAI,KAAKL,cAAT,EAAyB;AACvBK,MAAAA,KAAK,GAAG,CAAC,GAAG,KAAKL,cAAT,CAAR;AACA,WAAKA,cAAL,CAAoBM,MAApB,GAA6B,CAA7B;AACD;;AACD,WAAOD,KAAP;AACD;;AAODE,EAAAA,gBAAgB,GAAG;AACjB,WAAO,KAAKN,cAAZ;AACD;;AAEDO,EAAAA,oBAAoB,GAAG;AACrB,WAAO,KAAKT,iBAAZ;AACD;;AAEDU,EAAAA,4BAA4B,GAAG;AAC7B,WAAO,KAAKV,iBAAL,IAA0B,KAAKA,iBAAL,CAAuBW,QAAvB,EAAjC;AACD;;AAEDC,EAAAA,WAAW,GAAG;AACZ,WAAO,KAAKb,QAAZ;AACD;;AAODc,EAAAA,cAAc,GAAG;AACf,UAAMC,WAAW,GAAG,KAAKF,WAAL,EAApB;;AAKA,QAAI,KAAKf,SAAL,CAAeU,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,aAAO,IAAP;AACD;;AAED,SAAK,MAAMQ,QAAX,IAAuB,KAAKlB,SAA5B,EAAuC;AACrC,UAAIkB,QAAQ,CAACC,MAAT,CAAgBF,WAAhB,CAAJ,EAAkC;AAChC,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;;AAEDX,EAAAA,aAAa,GAAG;AAEd,SAAKc,MAAL,CAAYC,WAAZ,GAA0B,MAAM;AAC9B,UAAI,CAAC,KAAKjB,cAAV,EAA0B;AACxB,YAAI,KAAKY,cAAL,EAAJ,EAA2B;AAEzB,eAAKb,iBAAL,GAAyB,KAAKY,WAAL,GAAmBO,KAAnB,EAAzB;AACA,eAAKlB,cAAL,GAAsB,EAAtB;;AACA,eAAKmB,UAAL,CAAgB,KAAKnB,cAArB;;AACA;AACD;AACF;;AAED,WAAKmB,UAAL;AACD,KAZD;;AAeA,SAAKH,MAAL,CAAYI,YAAZ,GAA2BC,IAAI,IAAI;AACjC,UAAI,CAAC,KAAKpB,cAAV,EAA0B;AACxB,aAAKA,cAAL,GAAsB,EAAtB;;AACA,aAAKqB,WAAL,CAAiB,KAAKrB,cAAtB;AACD,OAHD,MAGO;AACL,aAAKqB,WAAL,CAAiB,EAAjB;AACD;;AACD,UAAI,OAAOD,IAAP,KAAgB,WAApB,EAAiC;AAC/B,aAAKL,MAAL,CAAYO,KAAZ,CAAkBF,IAAlB;AACD;AACF,KAVD;AAWD;;AArGyD","sourcesContent":["import {default as JSONParser} from './json-parser';\nimport JSONPath from '../jsonpath/jsonpath';\n\n/**\n * The `StreamingJSONParser` looks for the first array in the JSON structure.\n * and emits an array of chunks\n */\nexport default class StreamingJSONParser extends JSONParser {\n  constructor(options = {}) {\n    super();\n    const jsonpaths = options.jsonpaths || [];\n    this.jsonPaths = jsonpaths.map(jsonpath => new JSONPath(jsonpath));\n    this.streamingJsonPath = null;\n    this.streamingArray = null;\n    this.topLevelObject = null;\n    this._extendParser();\n  }\n\n  /**\n   * write REDEFINITION\n   * - super.write() chunk to parser\n   * - get the contents (so far) of \"topmost-level\" array as batch of rows\n   * - clear top-level array\n   * - return the batch of rows\\\n   */\n  write(chunk) {\n    super.write(chunk);\n    let array = [];\n    if (this.streamingArray) {\n      array = [...this.streamingArray];\n      this.streamingArray.length = 0;\n    }\n    return array;\n  }\n\n  /**\n   * Returns a partially formed result object\n   * Useful for returning the \"wrapper\" object when array is not top level\n   * e.g. GeoJSON\n   */\n  getPartialResult() {\n    return this.topLevelObject;\n  }\n\n  getStreamingJsonPath() {\n    return this.streamingJsonPath;\n  }\n\n  getStreamingJsonPathAsString() {\n    return this.streamingJsonPath && this.streamingJsonPath.toString();\n  }\n\n  getJsonPath() {\n    return this.jsonpath;\n  }\n\n  // PRIVATE METHODS\n\n  /**\n   * Checks is this.getJsonPath matches the jsonpaths provided in options\n   */\n  _matchJSONPath() {\n    const currentPath = this.getJsonPath();\n    // console.debug(`Testing JSONPath`, currentPath);\n\n    // Backwards compatibility, match any array\n    // TODO implement using wildcard once that is supported\n    if (this.jsonPaths.length === 0) {\n      return true;\n    }\n\n    for (const jsonPath of this.jsonPaths) {\n      if (jsonPath.equals(currentPath)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _extendParser() {\n    // Redefine onopenarray to locate and inject value for top-level array\n    this.parser.onopenarray = () => {\n      if (!this.streamingArray) {\n        if (this._matchJSONPath()) {\n          // @ts-ignore\n          this.streamingJsonPath = this.getJsonPath().clone();\n          this.streamingArray = [];\n          this._openArray(this.streamingArray);\n          return;\n        }\n      }\n\n      this._openArray();\n    };\n\n    // Redefine onopenarray to inject value for top-level object\n    this.parser.onopenobject = name => {\n      if (!this.topLevelObject) {\n        this.topLevelObject = {};\n        this._openObject(this.topLevelObject);\n      } else {\n        this._openObject({});\n      }\n      if (typeof name !== 'undefined') {\n        this.parser.onkey(name);\n      }\n    };\n  }\n}\n"],"file":"streaming-json-parser.js"}