{"version":3,"sources":["../../../src/lib/parse-json-in-batches.js"],"names":["makeTextDecoderIterator","TableBatchBuilder","StreamingJSONParser","parseJSONInBatches","asyncIterator","options","metadata","batchSize","_rootObjectBatches","jsonpaths","json","TableBatchType","TableBatch","isFirstChunk","tableBatchBuilder","schema","parser","chunk","rows","write","jsonpath","length","getStreamingJsonPathAsString","initialBatch","batchType","container","getPartialResult","data","bytesUsed","deduceSchema","row","addRow","isFull","getBatch","chunkComplete","batch","finalBatch","i","columnName","value","name","String","index","type","Float32Array","Array"],"mappings":"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","sourcesContent":["import {makeTextDecoderIterator} from '@loaders.gl/loader-utils';\nimport {TableBatchBuilder} from '@loaders.gl/tables';\nimport StreamingJSONParser from './parser/streaming-json-parser';\n\n// TODO - support batch size 0 = no batching/single batch?\n// eslint-disable-next-line max-statements, complexity\nexport default async function* parseJSONInBatches(asyncIterator, options) {\n  asyncIterator = makeTextDecoderIterator(asyncIterator);\n\n  const {metadata} = options;\n  const {batchSize, _rootObjectBatches, jsonpaths} = options.json;\n  const TableBatchType = options.json.TableBatch;\n\n  let isFirstChunk = true;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const parser = new StreamingJSONParser({jsonpaths});\n  tableBatchBuilder =\n    // @ts-ignore\n    tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, {batchSize});\n\n  for await (const chunk of asyncIterator) {\n    const rows = parser.write(chunk);\n\n    const jsonpath = rows.length > 0 && parser.getStreamingJsonPathAsString();\n\n    if (rows.length > 0 && isFirstChunk) {\n      if (metadata) {\n        const initialBatch = {\n          batchType: 'partial-result',\n          container: parser.getPartialResult(),\n          data: [],\n          bytesUsed: 0,\n          schema: null,\n          jsonpath\n        };\n        yield initialBatch;\n      }\n      // Backwards compabitility\n      if (_rootObjectBatches) {\n        const initialBatch = {\n          batchType: 'root-object-batch-partial',\n          container: parser.getPartialResult(),\n          data: [],\n          schema: null\n        };\n        yield initialBatch;\n      }\n      isFirstChunk = false;\n      schema = deduceSchema(rows);\n    }\n\n    // Add the row\n    for (const row of rows) {\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        yield tableBatchBuilder.getBatch({jsonpath});\n      }\n    }\n\n    tableBatchBuilder.chunkComplete(chunk);\n    if (tableBatchBuilder.isFull()) {\n      yield tableBatchBuilder.getBatch({jsonpath});\n    }\n  }\n\n  // yield final batch\n  const jsonpath = parser.getStreamingJsonPathAsString();\n  const batch = tableBatchBuilder.getBatch({jsonpath});\n  if (batch) {\n    yield batch;\n  }\n\n  if (metadata) {\n    const finalBatch = {\n      batchType: 'final-result',\n      container: parser.getPartialResult(),\n      jsonpath: parser.getStreamingJsonPathAsString(),\n      data: [],\n      schema: null\n    };\n    yield finalBatch;\n  }\n  if (_rootObjectBatches) {\n    const finalBatch = {\n      batchType: 'root-object-batch-complete',\n      container: parser.getPartialResult(),\n      data: [],\n      schema: null\n    };\n    yield finalBatch;\n  }\n}\n\nfunction deduceSchema(rows) {\n  const row = rows[0];\n\n  const schema = {};\n  let i = 0;\n  for (const columnName in row) {\n    const value = row[columnName];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n\n      case 'object':\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n    i++;\n  }\n  return schema;\n}\n"],"file":"parse-json-in-batches.js"}