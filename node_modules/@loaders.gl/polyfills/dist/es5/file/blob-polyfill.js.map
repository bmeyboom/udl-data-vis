{"version":3,"sources":["../../../src/file/blob-polyfill.js"],"names":["BlobStreamController","chunks","controller","work","isWorking","isCancelled","desiredSize","next","error","done","enqueue","value","close","BlobStream","values","type","_chunks","Symbol","asyncIterator","_options","reader","getReader","releaseLock","ReadableStreamPolyfill","BlobPolyfill","init","options","parts","size","part","bytes","TextEncoder","encode","push","byteLength","_parts","ArrayBuffer","Uint8Array","isView","buffer","byteOffset","String","_size","_type","readType","start","end","offset","Math","max","min","limit","span","blob","blobSize","blobParts","chunk","subarray","_toArrayBuffer","decoder","TextDecoder","text","decode","set","toStringTag","input","toLowerCase","test"],"mappings":"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","sourcesContent":["// Forked from @gozala's web-blob under MIT license https://github.com/Gozala/web-blob\n/* global TextEncoder, TextDecoder */\nimport {ReadableStreamPolyfill} from './readable-stream-polyfill';\n\n/**\n * Forked from @gozala's web-blob under MIT license\n * @see https://github.com/Gozala/web-blob\n */\nclass BlobStreamController {\n  /**\n   * @param {Iterator<Uint8Array>} chunks\n   */\n  constructor(chunks) {\n    this.chunks = chunks;\n  }\n\n  /**\n   * @param {ReadableStreamDefaultController} controller\n   */\n  start(controller) {\n    this.work(controller);\n    this.isWorking = false;\n    this.isCancelled = false;\n  }\n  /**\n   *\n   * @param {ReadableStreamDefaultController} controller\n   */\n  async work(controller) {\n    const {chunks} = this;\n\n    this.isWorking = true;\n    while (!this.isCancelled && (controller.desiredSize || 0) > 0) {\n      let next = null;\n      try {\n        next = chunks.next();\n      } catch (error) {\n        controller.error(error);\n        break;\n      }\n\n      if (next) {\n        if (!next.done && !this.isCancelled) {\n          controller.enqueue(next.value);\n        } else {\n          controller.close();\n        }\n      }\n    }\n\n    this.isWorking = false;\n  }\n\n  /**\n   *\n   * @param {ReadableStreamDefaultController} controller\n   */\n  pull(controller) {\n    if (!this.isWorking) {\n      this.work(controller);\n    }\n  }\n  cancel() {\n    this.isCancelled = true;\n  }\n}\n\n/**\n * Blob stream is a `ReadableStream` extension optimized to have minimal\n * overhead when consumed as `AsyncIterable<Uint8Array>`.\n * extends {ReadableStream<Uint8Array>}\n * implements {AsyncIterable<Uint8Array>}\n */\n// @ts-ignore\nclass BlobStream extends ReadableStreamPolyfill {\n  /**\n   * @param {Uint8Array[]} chunks\n   */\n  constructor(chunks) {\n    // @ts-ignore\n    super(new BlobStreamController(chunks.values()), {type: 'bytes'});\n    /** @private */\n    this._chunks = chunks;\n  }\n\n  /**\n   * @param {Object} [_options]\n   * @property {boolean} [_options.preventCancel]\n   * @returns {AsyncIterator<Uint8Array>}\n   */\n  async *[Symbol.asyncIterator](_options) {\n    const reader = this.getReader();\n    yield* this._chunks;\n    reader.releaseLock();\n  }\n}\n\n/**\n * Forked from @gozala's web-blob under MIT license\n * @see https://github.com/Gozala/web-blob\n */\nexport class BlobPolyfill {\n  /**\n   * @param {BlobPart[]} [init]\n   * @param {BlobPropertyBag} [options]\n   */\n  constructor(init = [], options = {}) {\n    /** @type {Uint8Array[]} */\n    const parts = [];\n\n    let size = 0;\n    for (const part of init) {\n      if (typeof part === 'string') {\n        const bytes = new TextEncoder().encode(part);\n        parts.push(bytes);\n        size += bytes.byteLength;\n      } else if (part instanceof BlobPolyfill) {\n        size += part.size;\n        // @ts-ignore - `_parts` is marked private so TS will complain about\n        // accessing it.\n        parts.push(...part._parts);\n      } else if (part instanceof ArrayBuffer) {\n        parts.push(new Uint8Array(part));\n        size += part.byteLength;\n      } else if (part instanceof Uint8Array) {\n        parts.push(part);\n        size += part.byteLength;\n      } else if (ArrayBuffer.isView(part)) {\n        const {buffer, byteOffset, byteLength} = part;\n        parts.push(new Uint8Array(buffer, byteOffset, byteLength));\n        size += byteLength;\n      } else {\n        const bytes = new TextEncoder().encode(String(part));\n        parts.push(bytes);\n        size += bytes.byteLength;\n      }\n    }\n\n    /** @private */\n    this._size = size;\n    /** @private */\n    this._type = readType(options.type);\n    /** @private */\n    this._parts = parts;\n  }\n\n  /**\n   * A string indicating the MIME type of the data contained in the Blob.\n   * If the type is unknown, this string is empty.\n   * @type {string}\n   */\n  get type() {\n    return this._type;\n  }\n  /**\n   * The size, in bytes, of the data contained in the Blob object.\n   * @type {number}\n   */\n  get size() {\n    return this._size;\n  }\n\n  /**\n   * Returns a new Blob object containing the data in the specified range of\n   * bytes of the blob on which it's called.\n   * @param {number} [start=0] - An index into the Blob indicating the first\n   * byte to include in the new Blob. If you specify a negative value, it's\n   * treated as an offset from the end of the Blob toward the beginning. For\n   * example, `-10` would be the 10th from last byte in the Blob. The default\n   * value is `0`. If you specify a value for start that is larger than the\n   * size of the source Blob, the returned Blob has size 0 and contains no\n   * data.\n   * @param {number} [end] - An index into the `Blob` indicating the first byte\n   *  that will *not* be included in the new `Blob` (i.e. the byte exactly at\n   * this index is not included). If you specify a negative value, it's treated\n   * as an offset from the end of the Blob toward the beginning. For example,\n   * `-10` would be the 10th from last byte in the `Blob`. The default value is\n   * size.\n   * @param {string} [type] - The content type to assign to the new Blob;\n   * this will be the value of its type property. The default value is an empty\n   * string.\n   * @returns {Blob}\n   */\n  slice(start = 0, end = this.size, type = '') {\n    const {size, _parts} = this;\n    let offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n\n    let limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n    const span = Math.max(limit - offset, 0);\n    const blob = new BlobPolyfill([], {type});\n\n    if (span === 0) {\n      return blob;\n    }\n\n    let blobSize = 0;\n    const blobParts = [];\n    for (const part of _parts) {\n      const {byteLength} = part;\n      if (offset > 0 && byteLength <= offset) {\n        offset -= byteLength;\n        limit -= byteLength;\n      } else {\n        const chunk = part.subarray(offset, Math.min(byteLength, limit));\n        blobParts.push(chunk);\n        blobSize += chunk.byteLength;\n        // no longer need to take that into account\n        offset = 0;\n\n        // don't add the overflow to new blobParts\n        if (blobSize >= span) {\n          break;\n        }\n      }\n    }\n\n    blob._parts = blobParts;\n    blob._size = blobSize;\n\n    return blob;\n  }\n\n  /**\n   * Returns a promise that resolves with an ArrayBuffer containing the entire\n   * contents of the Blob as binary data.\n   * @returns {Promise<ArrayBuffer>}\n   */\n  // eslint-disable-next-line require-await\n  async arrayBuffer() {\n    return this._toArrayBuffer();\n  }\n\n  /**\n   * Returns a promise that resolves with a USVString containing the entire\n   * contents of the Blob interpreted as UTF-8 text.\n   * @returns {Promise<string>}\n   */\n  // eslint-disable-next-line require-await\n  async text() {\n    const decoder = new TextDecoder();\n    let text = '';\n    for (const part of this._parts) {\n      text += decoder.decode(part);\n    }\n    return text;\n  }\n\n  /**\n   * @returns {BlobStream}\n   */\n  stream() {\n    return new BlobStream(this._parts);\n  }\n\n  /**\n   * @returns {string}\n   */\n  toString() {\n    return '[object Blob]';\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n\n  _toArrayBuffer() {\n    const buffer = new ArrayBuffer(this.size);\n    const bytes = new Uint8Array(buffer);\n    let offset = 0;\n    for (const part of this._parts) {\n      bytes.set(part, offset);\n      offset += part.byteLength;\n    }\n    return buffer;\n  }\n}\n\n/**\n * @param {string} [input]\n * @returns {string}\n */\nfunction readType(input = '') {\n  const type = String(input).toLowerCase();\n  return /[^\\u0020-\\u007E]/.test(type) ? '' : type;\n}\n"],"file":"blob-polyfill.js"}