"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = fetchNode;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _fs = _interopRequireDefault(require("fs"));

var _response = _interopRequireDefault(require("./response.node"));

var _headers = _interopRequireDefault(require("./headers.node"));

var _decodeDataUri2 = require("./utils/decode-data-uri.node");

var _streamUtils = require("./utils/stream-utils.node");

var isDataURL = function isDataURL(url) {
  return url.startsWith('data:');
};

var isRequestURL = function isRequestURL(url) {
  return url.startsWith('http:') || url.startsWith('https:');
};

function fetchNode(_x, _x2) {
  return _fetchNode.apply(this, arguments);
}

function _fetchNode() {
  _fetchNode = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(url, options) {
    var _decodeDataUri, arrayBuffer, mimeType, response, syntheticResponseHeaders, originalUrl, body, headers, _getStatus, status, statusText;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;

            if (!isDataURL(url)) {
              _context.next = 5;
              break;
            }

            _decodeDataUri = (0, _decodeDataUri2.decodeDataUri)(url), arrayBuffer = _decodeDataUri.arrayBuffer, mimeType = _decodeDataUri.mimeType;
            response = new _response["default"](arrayBuffer, {
              headers: {
                'content-type': mimeType,
                url: url
              }
            });
            return _context.abrupt("return", response);

          case 5:
            syntheticResponseHeaders = {};
            originalUrl = url;

            if (url.endsWith('.gz')) {
              url = url.slice(0, -3);
              syntheticResponseHeaders['content-encoding'] = 'gzip';
            }

            _context.next = 10;
            return (0, _streamUtils.createReadStream)(originalUrl, options);

          case 10:
            body = _context.sent;
            headers = getHeaders(url, body, syntheticResponseHeaders);
            _getStatus = getStatus(body), status = _getStatus.status, statusText = _getStatus.statusText;
            return _context.abrupt("return", new _response["default"](body, {
              headers: headers,
              status: status,
              statusText: statusText,
              url: url
            }));

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](0);
            return _context.abrupt("return", new _response["default"](null, {
              status: 400,
              statusText: String(_context.t0),
              url: url
            }));

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 16]]);
  }));
  return _fetchNode.apply(this, arguments);
}

function getStatus(httpResponse) {
  if (httpResponse.statusCode) {
    return {
      status: httpResponse.statusCode,
      statusText: httpResponse.statusMessage || 'NA'
    };
  }

  return {
    status: 200,
    statusText: 'OK'
  };
}

function getHeaders(url, httpResponse) {
  var additionalHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var headers = {};

  if (httpResponse && httpResponse.headers) {
    var httpHeaders = httpResponse.headers;

    for (var key in httpHeaders) {
      var header = httpHeaders[key];
      headers[key.toLowerCase()] = String(header);
    }
  }

  if (!headers['content-length']) {
    var contentLength = getContentLength(url);

    if (Number.isFinite(contentLength)) {
      headers['content-length'] = contentLength;
    }
  }

  Object.assign(headers, additionalHeaders);
  return new _headers["default"](headers);
}

function getContentLength(url) {
  if (isRequestURL(url)) {
    return null;
  } else if (isDataURL(url)) {
    return url.length - 'data:'.length;
  }

  try {
    var noqueryUrl = url.split('?')[0];

    var stats = _fs["default"].statSync(noqueryUrl);

    return stats.size;
  } catch (error) {}

  return null;
}
//# sourceMappingURL=fetch.node.js.map