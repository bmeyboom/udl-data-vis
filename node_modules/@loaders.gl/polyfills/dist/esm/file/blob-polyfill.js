import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _wrapAsyncGenerator from "@babel/runtime/helpers/esm/wrapAsyncGenerator";
import _awaitAsyncGenerator from "@babel/runtime/helpers/esm/awaitAsyncGenerator";
import _asyncIterator from "@babel/runtime/helpers/esm/asyncIterator";
import _asyncGeneratorDelegate from "@babel/runtime/helpers/esm/asyncGeneratorDelegate";

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

import { ReadableStreamPolyfill } from './readable-stream-polyfill';

var BlobStreamController = function () {
  function BlobStreamController(chunks) {
    _classCallCheck(this, BlobStreamController);

    this.chunks = chunks;
  }

  _createClass(BlobStreamController, [{
    key: "start",
    value: function start(controller) {
      this.work(controller);
      this.isWorking = false;
      this.isCancelled = false;
    }
  }, {
    key: "work",
    value: function () {
      var _work = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(controller) {
        var chunks, next;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                chunks = this.chunks;
                this.isWorking = true;

              case 2:
                if (!(!this.isCancelled && (controller.desiredSize || 0) > 0)) {
                  _context.next = 15;
                  break;
                }

                next = null;
                _context.prev = 4;
                next = chunks.next();
                _context.next = 12;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](4);
                controller.error(_context.t0);
                return _context.abrupt("break", 15);

              case 12:
                if (next) {
                  if (!next.done && !this.isCancelled) {
                    controller.enqueue(next.value);
                  } else {
                    controller.close();
                  }
                }

                _context.next = 2;
                break;

              case 15:
                this.isWorking = false;

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 8]]);
      }));

      function work(_x) {
        return _work.apply(this, arguments);
      }

      return work;
    }()
  }, {
    key: "pull",
    value: function pull(controller) {
      if (!this.isWorking) {
        this.work(controller);
      }
    }
  }, {
    key: "cancel",
    value: function cancel() {
      this.isCancelled = true;
    }
  }]);

  return BlobStreamController;
}();

var BlobStream = function (_ReadableStreamPolyfi) {
  _inherits(BlobStream, _ReadableStreamPolyfi);

  var _super = _createSuper(BlobStream);

  function BlobStream(chunks) {
    var _this2;

    _classCallCheck(this, BlobStream);

    _this2 = _super.call(this, new BlobStreamController(chunks.values()), {
      type: 'bytes'
    });
    _this2._chunks = chunks;
    return _this2;
  }

  _createClass(BlobStream, [{
    key: Symbol.asyncIterator,
    value: function value(_options) {
      var _this = this;

      return _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee2() {
        var reader;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                reader = _this.getReader();
                return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this._chunks), _awaitAsyncGenerator), "t0", 2);

              case 2:
                reader.releaseLock();

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    }
  }]);

  return BlobStream;
}(ReadableStreamPolyfill);

export var BlobPolyfill = function () {
  function BlobPolyfill() {
    var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, BlobPolyfill);

    var parts = [];
    var size = 0;

    var _iterator = _createForOfIteratorHelper(init),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var part = _step.value;

        if (typeof part === 'string') {
          var bytes = new TextEncoder().encode(part);
          parts.push(bytes);
          size += bytes.byteLength;
        } else if (part instanceof BlobPolyfill) {
          size += part.size;
          parts.push.apply(parts, _toConsumableArray(part._parts));
        } else if (part instanceof ArrayBuffer) {
          parts.push(new Uint8Array(part));
          size += part.byteLength;
        } else if (part instanceof Uint8Array) {
          parts.push(part);
          size += part.byteLength;
        } else if (ArrayBuffer.isView(part)) {
          var buffer = part.buffer,
              byteOffset = part.byteOffset,
              byteLength = part.byteLength;
          parts.push(new Uint8Array(buffer, byteOffset, byteLength));
          size += byteLength;
        } else {
          var _bytes = new TextEncoder().encode(String(part));

          parts.push(_bytes);
          size += _bytes.byteLength;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this._size = size;
    this._type = readType(options.type);
    this._parts = parts;
  }

  _createClass(BlobPolyfill, [{
    key: "slice",
    value: function slice() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var size = this.size,
          _parts = this._parts;
      var offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
      var limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
      var span = Math.max(limit - offset, 0);
      var blob = new BlobPolyfill([], {
        type: type
      });

      if (span === 0) {
        return blob;
      }

      var blobSize = 0;
      var blobParts = [];

      var _iterator2 = _createForOfIteratorHelper(_parts),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var part = _step2.value;
          var byteLength = part.byteLength;

          if (offset > 0 && byteLength <= offset) {
            offset -= byteLength;
            limit -= byteLength;
          } else {
            var chunk = part.subarray(offset, Math.min(byteLength, limit));
            blobParts.push(chunk);
            blobSize += chunk.byteLength;
            offset = 0;

            if (blobSize >= span) {
              break;
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      blob._parts = blobParts;
      blob._size = blobSize;
      return blob;
    }
  }, {
    key: "arrayBuffer",
    value: function () {
      var _arrayBuffer = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3() {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this._toArrayBuffer());

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function arrayBuffer() {
        return _arrayBuffer.apply(this, arguments);
      }

      return arrayBuffer;
    }()
  }, {
    key: "text",
    value: function () {
      var _text = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4() {
        var decoder, text, _iterator3, _step3, part;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                decoder = new TextDecoder();
                text = '';
                _iterator3 = _createForOfIteratorHelper(this._parts);

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    part = _step3.value;
                    text += decoder.decode(part);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                return _context4.abrupt("return", text);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function text() {
        return _text.apply(this, arguments);
      }

      return text;
    }()
  }, {
    key: "stream",
    value: function stream() {
      return new BlobStream(this._parts);
    }
  }, {
    key: "toString",
    value: function toString() {
      return '[object Blob]';
    }
  }, {
    key: "_toArrayBuffer",
    value: function _toArrayBuffer() {
      var buffer = new ArrayBuffer(this.size);
      var bytes = new Uint8Array(buffer);
      var offset = 0;

      var _iterator4 = _createForOfIteratorHelper(this._parts),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var part = _step4.value;
          bytes.set(part, offset);
          offset += part.byteLength;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return buffer;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Blob';
    }
  }]);

  return BlobPolyfill;
}();

function readType() {
  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var type = String(input).toLowerCase();
  return /[^\u0020-\u007E]/.test(type) ? '' : type;
}
//# sourceMappingURL=blob-polyfill.js.map