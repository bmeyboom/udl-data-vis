import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import fs from 'fs';
import Response from './response.node';
import Headers from './headers.node';
import { decodeDataUri } from './utils/decode-data-uri.node';
import { createReadStream } from './utils/stream-utils.node';

var isDataURL = function isDataURL(url) {
  return url.startsWith('data:');
};

var isRequestURL = function isRequestURL(url) {
  return url.startsWith('http:') || url.startsWith('https:');
};

export default function fetchNode(_x, _x2) {
  return _fetchNode.apply(this, arguments);
}

function _fetchNode() {
  _fetchNode = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(url, options) {
    var _decodeDataUri, arrayBuffer, mimeType, response, syntheticResponseHeaders, originalUrl, body, headers, _getStatus, status, statusText;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;

            if (!isDataURL(url)) {
              _context.next = 5;
              break;
            }

            _decodeDataUri = decodeDataUri(url), arrayBuffer = _decodeDataUri.arrayBuffer, mimeType = _decodeDataUri.mimeType;
            response = new Response(arrayBuffer, {
              headers: {
                'content-type': mimeType,
                url: url
              }
            });
            return _context.abrupt("return", response);

          case 5:
            syntheticResponseHeaders = {};
            originalUrl = url;

            if (url.endsWith('.gz')) {
              url = url.slice(0, -3);
              syntheticResponseHeaders['content-encoding'] = 'gzip';
            }

            _context.next = 10;
            return createReadStream(originalUrl, options);

          case 10:
            body = _context.sent;
            headers = getHeaders(url, body, syntheticResponseHeaders);
            _getStatus = getStatus(body), status = _getStatus.status, statusText = _getStatus.statusText;
            return _context.abrupt("return", new Response(body, {
              headers: headers,
              status: status,
              statusText: statusText,
              url: url
            }));

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](0);
            return _context.abrupt("return", new Response(null, {
              status: 400,
              statusText: String(_context.t0),
              url: url
            }));

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 16]]);
  }));
  return _fetchNode.apply(this, arguments);
}

function getStatus(httpResponse) {
  if (httpResponse.statusCode) {
    return {
      status: httpResponse.statusCode,
      statusText: httpResponse.statusMessage || 'NA'
    };
  }

  return {
    status: 200,
    statusText: 'OK'
  };
}

function getHeaders(url, httpResponse) {
  var additionalHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var headers = {};

  if (httpResponse && httpResponse.headers) {
    var httpHeaders = httpResponse.headers;

    for (var key in httpHeaders) {
      var header = httpHeaders[key];
      headers[key.toLowerCase()] = String(header);
    }
  }

  if (!headers['content-length']) {
    var contentLength = getContentLength(url);

    if (Number.isFinite(contentLength)) {
      headers['content-length'] = contentLength;
    }
  }

  Object.assign(headers, additionalHeaders);
  return new Headers(headers);
}

function getContentLength(url) {
  if (isRequestURL(url)) {
    return null;
  } else if (isDataURL(url)) {
    return url.length - 'data:'.length;
  }

  try {
    var noqueryUrl = url.split('?')[0];
    var stats = fs.statSync(noqueryUrl);
    return stats.size;
  } catch (error) {}

  return null;
}
//# sourceMappingURL=fetch.node.js.map