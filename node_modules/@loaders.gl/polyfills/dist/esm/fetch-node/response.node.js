import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _typeof from "@babel/runtime/helpers/esm/typeof";
import assert from '../utils/assert';
import { decompressReadStream, concatenateReadStream } from './utils/stream-utils.node';
import Headers from './headers.node';

var isBoolean = function isBoolean(x) {
  return typeof x === 'boolean';
};

var isFunction = function isFunction(x) {
  return typeof x === 'function';
};

var isObject = function isObject(x) {
  return x !== null && _typeof(x) === 'object';
};

var isReadableNodeStream = function isReadableNodeStream(x) {
  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
};

import { Readable } from 'stream';

var Response = function () {
  function Response(body) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Response);

    var headers = options.headers,
        _options$status = options.status,
        status = _options$status === void 0 ? 200 : _options$status,
        statusText = options.statusText,
        url = options.url;
    this._url = url;
    this._ok = status === 200;
    this._status = status;
    this._statusText = statusText;
    this._headers = new Headers(headers);
    this.bodyUsed = false;

    if (isReadableNodeStream(body)) {
      this._body = decompressReadStream(body, headers);
    } else if (typeof body === 'string') {
      this._body = Readable.from([new TextEncoder().encode(body)]);
    } else {
      this._body = Readable.from([body || new ArrayBuffer(0)]);
    }
  }

  _createClass(Response, [{
    key: "arrayBuffer",
    value: function () {
      var _arrayBuffer = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {
        var data;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isReadableNodeStream(this._body)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this._body || new ArrayBuffer(0));

              case 2:
                _context.next = 4;
                return concatenateReadStream(this._body);

              case 4:
                data = _context.sent;
                return _context.abrupt("return", data);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function arrayBuffer() {
        return _arrayBuffer.apply(this, arguments);
      }

      return arrayBuffer;
    }()
  }, {
    key: "text",
    value: function () {
      var _text = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {
        var arrayBuffer, textDecoder;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.arrayBuffer();

              case 2:
                arrayBuffer = _context2.sent;
                textDecoder = new TextDecoder();
                return _context2.abrupt("return", textDecoder.decode(arrayBuffer));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function text() {
        return _text.apply(this, arguments);
      }

      return text;
    }()
  }, {
    key: "json",
    value: function () {
      var _json = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3() {
        var text;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.text();

              case 2:
                text = _context3.sent;
                return _context3.abrupt("return", JSON.parse(text));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function json() {
        return _json.apply(this, arguments);
      }

      return json;
    }()
  }, {
    key: "blob",
    value: function () {
      var _blob = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4() {
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(typeof Blob === 'undefined')) {
                  _context4.next = 2;
                  break;
                }

                throw new Error('Blob polyfill not installed');

              case 2:
                _context4.t0 = Blob;
                _context4.next = 5;
                return this.arrayBuffer();

              case 5:
                _context4.t1 = _context4.sent;
                _context4.t2 = [_context4.t1];
                return _context4.abrupt("return", new _context4.t0(_context4.t2));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function blob() {
        return _blob.apply(this, arguments);
      }

      return blob;
    }()
  }, {
    key: "ok",
    get: function get() {
      return this._ok;
    }
  }, {
    key: "status",
    get: function get() {
      return this._status;
    }
  }, {
    key: "statusText",
    get: function get() {
      return this._statusText;
    }
  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
  }, {
    key: "headers",
    get: function get() {
      return this._headers;
    }
  }, {
    key: "body",
    get: function get() {
      assert(!this.bodyUsed);
      assert(isReadableNodeStream(this._body));
      this.bodyUsed = true;
      return this._body;
    }
  }]);

  return Response;
}();

export { Response as default };
//# sourceMappingURL=response.node.js.map