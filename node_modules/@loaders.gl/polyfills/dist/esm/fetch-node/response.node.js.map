{"version":3,"sources":["../../../src/fetch-node/response.node.js"],"names":["assert","decompressReadStream","concatenateReadStream","Headers","isBoolean","x","isFunction","isObject","isReadableNodeStream","read","pipe","readable","Readable","Response","body","options","headers","status","statusText","url","_url","_ok","_status","_statusText","_headers","bodyUsed","_body","from","TextEncoder","encode","ArrayBuffer","data","arrayBuffer","textDecoder","TextDecoder","decode","text","JSON","parse","Blob","Error"],"mappings":"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","sourcesContent":["/* global TextDecoder, TextEncoder, Blob */\nimport assert from '../utils/assert';\nimport {decompressReadStream, concatenateReadStream} from './utils/stream-utils.node';\nimport Headers from './headers.node';\n\nconst isBoolean = x => typeof x === 'boolean';\nconst isFunction = x => typeof x === 'function';\nconst isObject = x => x !== null && typeof x === 'object';\nconst isReadableNodeStream = x =>\n  isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);\n\n/**\n * Polyfill for Browser Response\n *\n * Under Node.js we return a mock \"fetch response object\"\n * so that apps can use the same API as in the browser.\n *\n * Note: This is intended to be a \"lightweight\" implementation and will have limitations.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/Response\n */\nimport {Readable} from 'stream';\n\nexport default class Response {\n  // TODO - handle ArrayBuffer, ArrayBufferView, Buffer\n  constructor(body, options = {}) {\n    const {headers, status = 200, statusText, url} = options;\n\n    this._url = url;\n    this._ok = status === 200;\n    this._status = status; // TODO - handle errors and set status\n    this._statusText = statusText;\n    this._headers = new Headers(headers);\n    this.bodyUsed = false;\n\n    // Check for content-encoding and create a decompression stream\n    if (isReadableNodeStream(body)) {\n      this._body = decompressReadStream(body, headers);\n    } else if (typeof body === 'string') {\n      this._body = Readable.from([new TextEncoder().encode(body)]);\n    } else {\n      this._body = Readable.from([body || new ArrayBuffer(0)]);\n    }\n  }\n\n  // Subset of Properties\n\n  get ok() {\n    return this._ok;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  get statusText() {\n    return this._statusText;\n  }\n\n  get url() {\n    return this._url;\n  }\n\n  get headers() {\n    return this._headers;\n  }\n\n  // Returns a readable stream to the \"body\" of the response (or file)\n  get body() {\n    assert(!this.bodyUsed);\n    assert(isReadableNodeStream(this._body)); // Not implemented: conversion of ArrayBuffer etc to stream\n    this.bodyUsed = true;\n    return this._body;\n  }\n\n  // Subset of Methods\n\n  async arrayBuffer() {\n    if (!isReadableNodeStream(this._body)) {\n      return this._body || new ArrayBuffer(0);\n    }\n    const data = await concatenateReadStream(this._body);\n    return data;\n  }\n\n  async text() {\n    const arrayBuffer = await this.arrayBuffer();\n    const textDecoder = new TextDecoder();\n    return textDecoder.decode(arrayBuffer);\n  }\n\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n\n  async blob() {\n    if (typeof Blob === 'undefined') {\n      throw new Error('Blob polyfill not installed');\n    }\n    return new Blob([await this.arrayBuffer()]);\n  }\n}\n"],"file":"response.node.js"}