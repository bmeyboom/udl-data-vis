{"version":3,"sources":["../../../src/file/blob-polyfill.js"],"names":["ReadableStreamPolyfill","BlobStreamController","constructor","chunks","start","controller","work","isWorking","isCancelled","desiredSize","next","error","done","enqueue","value","close","pull","cancel","BlobStream","values","type","_chunks","Symbol","asyncIterator","_options","reader","getReader","releaseLock","BlobPolyfill","init","options","parts","size","part","bytes","TextEncoder","encode","push","byteLength","_parts","ArrayBuffer","Uint8Array","isView","buffer","byteOffset","String","_size","_type","readType","slice","end","offset","Math","max","min","limit","span","blob","blobSize","blobParts","chunk","subarray","arrayBuffer","_toArrayBuffer","text","decoder","TextDecoder","decode","stream","toString","toStringTag","set","input","toLowerCase","test"],"mappings":"AAEA,SAAQA,sBAAR,QAAqC,4BAArC;;AAMA,MAAMC,oBAAN,CAA2B;AAIzBC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,SAAKA,MAAL,GAAcA,MAAd;AACD;;AAKDC,EAAAA,KAAK,CAACC,UAAD,EAAa;AAChB,SAAKC,IAAL,CAAUD,UAAV;AACA,SAAKE,SAAL,GAAiB,KAAjB;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACD;;AAKD,QAAMF,IAAN,CAAWD,UAAX,EAAuB;AACrB,UAAM;AAACF,MAAAA;AAAD,QAAW,IAAjB;AAEA,SAAKI,SAAL,GAAiB,IAAjB;;AACA,WAAO,CAAC,KAAKC,WAAN,IAAqB,CAACH,UAAU,CAACI,WAAX,IAA0B,CAA3B,IAAgC,CAA5D,EAA+D;AAC7D,UAAIC,IAAI,GAAG,IAAX;;AACA,UAAI;AACFA,QAAAA,IAAI,GAAGP,MAAM,CAACO,IAAP,EAAP;AACD,OAFD,CAEE,OAAOC,KAAP,EAAc;AACdN,QAAAA,UAAU,CAACM,KAAX,CAAiBA,KAAjB;AACA;AACD;;AAED,UAAID,IAAJ,EAAU;AACR,YAAI,CAACA,IAAI,CAACE,IAAN,IAAc,CAAC,KAAKJ,WAAxB,EAAqC;AACnCH,UAAAA,UAAU,CAACQ,OAAX,CAAmBH,IAAI,CAACI,KAAxB;AACD,SAFD,MAEO;AACLT,UAAAA,UAAU,CAACU,KAAX;AACD;AACF;AACF;;AAED,SAAKR,SAAL,GAAiB,KAAjB;AACD;;AAMDS,EAAAA,IAAI,CAACX,UAAD,EAAa;AACf,QAAI,CAAC,KAAKE,SAAV,EAAqB;AACnB,WAAKD,IAAL,CAAUD,UAAV;AACD;AACF;;AACDY,EAAAA,MAAM,GAAG;AACP,SAAKT,WAAL,GAAmB,IAAnB;AACD;;AAxDwB;;AAkE3B,MAAMU,UAAN,SAAyBlB,sBAAzB,CAAgD;AAI9CE,EAAAA,WAAW,CAACC,MAAD,EAAS;AAElB,UAAM,IAAIF,oBAAJ,CAAyBE,MAAM,CAACgB,MAAP,EAAzB,CAAN,EAAiD;AAACC,MAAAA,IAAI,EAAE;AAAP,KAAjD;AAEA,SAAKC,OAAL,GAAelB,MAAf;AACD;;AAOD,UAAQmB,MAAM,CAACC,aAAf,EAA8BC,QAA9B,EAAwC;AACtC,UAAMC,MAAM,GAAG,KAAKC,SAAL,EAAf;AACA,WAAO,KAAKL,OAAZ;AACAI,IAAAA,MAAM,CAACE,WAAP;AACD;;AApB6C;;AA2BhD,OAAO,MAAMC,YAAN,CAAmB;AAKxB1B,EAAAA,WAAW,CAAC2B,IAAI,GAAG,EAAR,EAAYC,OAAO,GAAG,EAAtB,EAA0B;AAEnC,UAAMC,KAAK,GAAG,EAAd;AAEA,QAAIC,IAAI,GAAG,CAAX;;AACA,SAAK,MAAMC,IAAX,IAAmBJ,IAAnB,EAAyB;AACvB,UAAI,OAAOI,IAAP,KAAgB,QAApB,EAA8B;AAC5B,cAAMC,KAAK,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBH,IAAzB,CAAd;AACAF,QAAAA,KAAK,CAACM,IAAN,CAAWH,KAAX;AACAF,QAAAA,IAAI,IAAIE,KAAK,CAACI,UAAd;AACD,OAJD,MAIO,IAAIL,IAAI,YAAYL,YAApB,EAAkC;AACvCI,QAAAA,IAAI,IAAIC,IAAI,CAACD,IAAb;AAGAD,QAAAA,KAAK,CAACM,IAAN,CAAW,GAAGJ,IAAI,CAACM,MAAnB;AACD,OALM,MAKA,IAAIN,IAAI,YAAYO,WAApB,EAAiC;AACtCT,QAAAA,KAAK,CAACM,IAAN,CAAW,IAAII,UAAJ,CAAeR,IAAf,CAAX;AACAD,QAAAA,IAAI,IAAIC,IAAI,CAACK,UAAb;AACD,OAHM,MAGA,IAAIL,IAAI,YAAYQ,UAApB,EAAgC;AACrCV,QAAAA,KAAK,CAACM,IAAN,CAAWJ,IAAX;AACAD,QAAAA,IAAI,IAAIC,IAAI,CAACK,UAAb;AACD,OAHM,MAGA,IAAIE,WAAW,CAACE,MAAZ,CAAmBT,IAAnB,CAAJ,EAA8B;AACnC,cAAM;AAACU,UAAAA,MAAD;AAASC,UAAAA,UAAT;AAAqBN,UAAAA;AAArB,YAAmCL,IAAzC;AACAF,QAAAA,KAAK,CAACM,IAAN,CAAW,IAAII,UAAJ,CAAeE,MAAf,EAAuBC,UAAvB,EAAmCN,UAAnC,CAAX;AACAN,QAAAA,IAAI,IAAIM,UAAR;AACD,OAJM,MAIA;AACL,cAAMJ,KAAK,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBS,MAAM,CAACZ,IAAD,CAA/B,CAAd;AACAF,QAAAA,KAAK,CAACM,IAAN,CAAWH,KAAX;AACAF,QAAAA,IAAI,IAAIE,KAAK,CAACI,UAAd;AACD;AACF;;AAGD,SAAKQ,KAAL,GAAad,IAAb;AAEA,SAAKe,KAAL,GAAaC,QAAQ,CAAClB,OAAO,CAACV,IAAT,CAArB;AAEA,SAAKmB,MAAL,GAAcR,KAAd;AACD;;AAOD,MAAIX,IAAJ,GAAW;AACT,WAAO,KAAK2B,KAAZ;AACD;;AAKD,MAAIf,IAAJ,GAAW;AACT,WAAO,KAAKc,KAAZ;AACD;;AAuBDG,EAAAA,KAAK,CAAC7C,KAAK,GAAG,CAAT,EAAY8C,GAAG,GAAG,KAAKlB,IAAvB,EAA6BZ,IAAI,GAAG,EAApC,EAAwC;AAC3C,UAAM;AAACY,MAAAA,IAAD;AAAOO,MAAAA;AAAP,QAAiB,IAAvB;AACA,QAAIY,MAAM,GAAG/C,KAAK,GAAG,CAAR,GAAYgD,IAAI,CAACC,GAAL,CAASrB,IAAI,GAAG5B,KAAhB,EAAuB,CAAvB,CAAZ,GAAwCgD,IAAI,CAACE,GAAL,CAASlD,KAAT,EAAgB4B,IAAhB,CAArD;AAEA,QAAIuB,KAAK,GAAGL,GAAG,GAAG,CAAN,GAAUE,IAAI,CAACC,GAAL,CAASrB,IAAI,GAAGkB,GAAhB,EAAqB,CAArB,CAAV,GAAoCE,IAAI,CAACE,GAAL,CAASJ,GAAT,EAAclB,IAAd,CAAhD;AACA,UAAMwB,IAAI,GAAGJ,IAAI,CAACC,GAAL,CAASE,KAAK,GAAGJ,MAAjB,EAAyB,CAAzB,CAAb;AACA,UAAMM,IAAI,GAAG,IAAI7B,YAAJ,CAAiB,EAAjB,EAAqB;AAACR,MAAAA;AAAD,KAArB,CAAb;;AAEA,QAAIoC,IAAI,KAAK,CAAb,EAAgB;AACd,aAAOC,IAAP;AACD;;AAED,QAAIC,QAAQ,GAAG,CAAf;AACA,UAAMC,SAAS,GAAG,EAAlB;;AACA,SAAK,MAAM1B,IAAX,IAAmBM,MAAnB,EAA2B;AACzB,YAAM;AAACD,QAAAA;AAAD,UAAeL,IAArB;;AACA,UAAIkB,MAAM,GAAG,CAAT,IAAcb,UAAU,IAAIa,MAAhC,EAAwC;AACtCA,QAAAA,MAAM,IAAIb,UAAV;AACAiB,QAAAA,KAAK,IAAIjB,UAAT;AACD,OAHD,MAGO;AACL,cAAMsB,KAAK,GAAG3B,IAAI,CAAC4B,QAAL,CAAcV,MAAd,EAAsBC,IAAI,CAACE,GAAL,CAAShB,UAAT,EAAqBiB,KAArB,CAAtB,CAAd;AACAI,QAAAA,SAAS,CAACtB,IAAV,CAAeuB,KAAf;AACAF,QAAAA,QAAQ,IAAIE,KAAK,CAACtB,UAAlB;AAEAa,QAAAA,MAAM,GAAG,CAAT;;AAGA,YAAIO,QAAQ,IAAIF,IAAhB,EAAsB;AACpB;AACD;AACF;AACF;;AAEDC,IAAAA,IAAI,CAAClB,MAAL,GAAcoB,SAAd;AACAF,IAAAA,IAAI,CAACX,KAAL,GAAaY,QAAb;AAEA,WAAOD,IAAP;AACD;;AAQD,QAAMK,WAAN,GAAoB;AAClB,WAAO,KAAKC,cAAL,EAAP;AACD;;AAQD,QAAMC,IAAN,GAAa;AACX,UAAMC,OAAO,GAAG,IAAIC,WAAJ,EAAhB;AACA,QAAIF,IAAI,GAAG,EAAX;;AACA,SAAK,MAAM/B,IAAX,IAAmB,KAAKM,MAAxB,EAAgC;AAC9ByB,MAAAA,IAAI,IAAIC,OAAO,CAACE,MAAR,CAAelC,IAAf,CAAR;AACD;;AACD,WAAO+B,IAAP;AACD;;AAKDI,EAAAA,MAAM,GAAG;AACP,WAAO,IAAIlD,UAAJ,CAAe,KAAKqB,MAApB,CAAP;AACD;;AAKD8B,EAAAA,QAAQ,GAAG;AACT,WAAO,eAAP;AACD;;AAED,OAAK/C,MAAM,CAACgD,WAAZ,IAA2B;AACzB,WAAO,MAAP;AACD;;AAEDP,EAAAA,cAAc,GAAG;AACf,UAAMpB,MAAM,GAAG,IAAIH,WAAJ,CAAgB,KAAKR,IAArB,CAAf;AACA,UAAME,KAAK,GAAG,IAAIO,UAAJ,CAAeE,MAAf,CAAd;AACA,QAAIQ,MAAM,GAAG,CAAb;;AACA,SAAK,MAAMlB,IAAX,IAAmB,KAAKM,MAAxB,EAAgC;AAC9BL,MAAAA,KAAK,CAACqC,GAAN,CAAUtC,IAAV,EAAgBkB,MAAhB;AACAA,MAAAA,MAAM,IAAIlB,IAAI,CAACK,UAAf;AACD;;AACD,WAAOK,MAAP;AACD;;AA7KuB;;AAoL1B,SAASK,QAAT,CAAkBwB,KAAK,GAAG,EAA1B,EAA8B;AAC5B,QAAMpD,IAAI,GAAGyB,MAAM,CAAC2B,KAAD,CAAN,CAAcC,WAAd,EAAb;AACA,SAAO,mBAAmBC,IAAnB,CAAwBtD,IAAxB,IAAgC,EAAhC,GAAqCA,IAA5C;AACD","sourcesContent":["// Forked from @gozala's web-blob under MIT license https://github.com/Gozala/web-blob\n/* global TextEncoder, TextDecoder */\nimport {ReadableStreamPolyfill} from './readable-stream-polyfill';\n\n/**\n * Forked from @gozala's web-blob under MIT license\n * @see https://github.com/Gozala/web-blob\n */\nclass BlobStreamController {\n  /**\n   * @param {Iterator<Uint8Array>} chunks\n   */\n  constructor(chunks) {\n    this.chunks = chunks;\n  }\n\n  /**\n   * @param {ReadableStreamDefaultController} controller\n   */\n  start(controller) {\n    this.work(controller);\n    this.isWorking = false;\n    this.isCancelled = false;\n  }\n  /**\n   *\n   * @param {ReadableStreamDefaultController} controller\n   */\n  async work(controller) {\n    const {chunks} = this;\n\n    this.isWorking = true;\n    while (!this.isCancelled && (controller.desiredSize || 0) > 0) {\n      let next = null;\n      try {\n        next = chunks.next();\n      } catch (error) {\n        controller.error(error);\n        break;\n      }\n\n      if (next) {\n        if (!next.done && !this.isCancelled) {\n          controller.enqueue(next.value);\n        } else {\n          controller.close();\n        }\n      }\n    }\n\n    this.isWorking = false;\n  }\n\n  /**\n   *\n   * @param {ReadableStreamDefaultController} controller\n   */\n  pull(controller) {\n    if (!this.isWorking) {\n      this.work(controller);\n    }\n  }\n  cancel() {\n    this.isCancelled = true;\n  }\n}\n\n/**\n * Blob stream is a `ReadableStream` extension optimized to have minimal\n * overhead when consumed as `AsyncIterable<Uint8Array>`.\n * extends {ReadableStream<Uint8Array>}\n * implements {AsyncIterable<Uint8Array>}\n */\n// @ts-ignore\nclass BlobStream extends ReadableStreamPolyfill {\n  /**\n   * @param {Uint8Array[]} chunks\n   */\n  constructor(chunks) {\n    // @ts-ignore\n    super(new BlobStreamController(chunks.values()), {type: 'bytes'});\n    /** @private */\n    this._chunks = chunks;\n  }\n\n  /**\n   * @param {Object} [_options]\n   * @property {boolean} [_options.preventCancel]\n   * @returns {AsyncIterator<Uint8Array>}\n   */\n  async *[Symbol.asyncIterator](_options) {\n    const reader = this.getReader();\n    yield* this._chunks;\n    reader.releaseLock();\n  }\n}\n\n/**\n * Forked from @gozala's web-blob under MIT license\n * @see https://github.com/Gozala/web-blob\n */\nexport class BlobPolyfill {\n  /**\n   * @param {BlobPart[]} [init]\n   * @param {BlobPropertyBag} [options]\n   */\n  constructor(init = [], options = {}) {\n    /** @type {Uint8Array[]} */\n    const parts = [];\n\n    let size = 0;\n    for (const part of init) {\n      if (typeof part === 'string') {\n        const bytes = new TextEncoder().encode(part);\n        parts.push(bytes);\n        size += bytes.byteLength;\n      } else if (part instanceof BlobPolyfill) {\n        size += part.size;\n        // @ts-ignore - `_parts` is marked private so TS will complain about\n        // accessing it.\n        parts.push(...part._parts);\n      } else if (part instanceof ArrayBuffer) {\n        parts.push(new Uint8Array(part));\n        size += part.byteLength;\n      } else if (part instanceof Uint8Array) {\n        parts.push(part);\n        size += part.byteLength;\n      } else if (ArrayBuffer.isView(part)) {\n        const {buffer, byteOffset, byteLength} = part;\n        parts.push(new Uint8Array(buffer, byteOffset, byteLength));\n        size += byteLength;\n      } else {\n        const bytes = new TextEncoder().encode(String(part));\n        parts.push(bytes);\n        size += bytes.byteLength;\n      }\n    }\n\n    /** @private */\n    this._size = size;\n    /** @private */\n    this._type = readType(options.type);\n    /** @private */\n    this._parts = parts;\n  }\n\n  /**\n   * A string indicating the MIME type of the data contained in the Blob.\n   * If the type is unknown, this string is empty.\n   * @type {string}\n   */\n  get type() {\n    return this._type;\n  }\n  /**\n   * The size, in bytes, of the data contained in the Blob object.\n   * @type {number}\n   */\n  get size() {\n    return this._size;\n  }\n\n  /**\n   * Returns a new Blob object containing the data in the specified range of\n   * bytes of the blob on which it's called.\n   * @param {number} [start=0] - An index into the Blob indicating the first\n   * byte to include in the new Blob. If you specify a negative value, it's\n   * treated as an offset from the end of the Blob toward the beginning. For\n   * example, `-10` would be the 10th from last byte in the Blob. The default\n   * value is `0`. If you specify a value for start that is larger than the\n   * size of the source Blob, the returned Blob has size 0 and contains no\n   * data.\n   * @param {number} [end] - An index into the `Blob` indicating the first byte\n   *  that will *not* be included in the new `Blob` (i.e. the byte exactly at\n   * this index is not included). If you specify a negative value, it's treated\n   * as an offset from the end of the Blob toward the beginning. For example,\n   * `-10` would be the 10th from last byte in the `Blob`. The default value is\n   * size.\n   * @param {string} [type] - The content type to assign to the new Blob;\n   * this will be the value of its type property. The default value is an empty\n   * string.\n   * @returns {Blob}\n   */\n  slice(start = 0, end = this.size, type = '') {\n    const {size, _parts} = this;\n    let offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n\n    let limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n    const span = Math.max(limit - offset, 0);\n    const blob = new BlobPolyfill([], {type});\n\n    if (span === 0) {\n      return blob;\n    }\n\n    let blobSize = 0;\n    const blobParts = [];\n    for (const part of _parts) {\n      const {byteLength} = part;\n      if (offset > 0 && byteLength <= offset) {\n        offset -= byteLength;\n        limit -= byteLength;\n      } else {\n        const chunk = part.subarray(offset, Math.min(byteLength, limit));\n        blobParts.push(chunk);\n        blobSize += chunk.byteLength;\n        // no longer need to take that into account\n        offset = 0;\n\n        // don't add the overflow to new blobParts\n        if (blobSize >= span) {\n          break;\n        }\n      }\n    }\n\n    blob._parts = blobParts;\n    blob._size = blobSize;\n\n    return blob;\n  }\n\n  /**\n   * Returns a promise that resolves with an ArrayBuffer containing the entire\n   * contents of the Blob as binary data.\n   * @returns {Promise<ArrayBuffer>}\n   */\n  // eslint-disable-next-line require-await\n  async arrayBuffer() {\n    return this._toArrayBuffer();\n  }\n\n  /**\n   * Returns a promise that resolves with a USVString containing the entire\n   * contents of the Blob interpreted as UTF-8 text.\n   * @returns {Promise<string>}\n   */\n  // eslint-disable-next-line require-await\n  async text() {\n    const decoder = new TextDecoder();\n    let text = '';\n    for (const part of this._parts) {\n      text += decoder.decode(part);\n    }\n    return text;\n  }\n\n  /**\n   * @returns {BlobStream}\n   */\n  stream() {\n    return new BlobStream(this._parts);\n  }\n\n  /**\n   * @returns {string}\n   */\n  toString() {\n    return '[object Blob]';\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n\n  _toArrayBuffer() {\n    const buffer = new ArrayBuffer(this.size);\n    const bytes = new Uint8Array(buffer);\n    let offset = 0;\n    for (const part of this._parts) {\n      bytes.set(part, offset);\n      offset += part.byteLength;\n    }\n    return buffer;\n  }\n}\n\n/**\n * @param {string} [input]\n * @returns {string}\n */\nfunction readType(input = '') {\n  const type = String(input).toLowerCase();\n  return /[^\\u0020-\\u007E]/.test(type) ? '' : type;\n}\n"],"file":"blob-polyfill.js"}