import { ReadableStreamPolyfill } from './readable-stream-polyfill';

class BlobStreamController {
  constructor(chunks) {
    this.chunks = chunks;
  }

  start(controller) {
    this.work(controller);
    this.isWorking = false;
    this.isCancelled = false;
  }

  async work(controller) {
    const {
      chunks
    } = this;
    this.isWorking = true;

    while (!this.isCancelled && (controller.desiredSize || 0) > 0) {
      let next = null;

      try {
        next = chunks.next();
      } catch (error) {
        controller.error(error);
        break;
      }

      if (next) {
        if (!next.done && !this.isCancelled) {
          controller.enqueue(next.value);
        } else {
          controller.close();
        }
      }
    }

    this.isWorking = false;
  }

  pull(controller) {
    if (!this.isWorking) {
      this.work(controller);
    }
  }

  cancel() {
    this.isCancelled = true;
  }

}

class BlobStream extends ReadableStreamPolyfill {
  constructor(chunks) {
    super(new BlobStreamController(chunks.values()), {
      type: 'bytes'
    });
    this._chunks = chunks;
  }

  async *[Symbol.asyncIterator](_options) {
    const reader = this.getReader();
    yield* this._chunks;
    reader.releaseLock();
  }

}

export class BlobPolyfill {
  constructor(init = [], options = {}) {
    const parts = [];
    let size = 0;

    for (const part of init) {
      if (typeof part === 'string') {
        const bytes = new TextEncoder().encode(part);
        parts.push(bytes);
        size += bytes.byteLength;
      } else if (part instanceof BlobPolyfill) {
        size += part.size;
        parts.push(...part._parts);
      } else if (part instanceof ArrayBuffer) {
        parts.push(new Uint8Array(part));
        size += part.byteLength;
      } else if (part instanceof Uint8Array) {
        parts.push(part);
        size += part.byteLength;
      } else if (ArrayBuffer.isView(part)) {
        const {
          buffer,
          byteOffset,
          byteLength
        } = part;
        parts.push(new Uint8Array(buffer, byteOffset, byteLength));
        size += byteLength;
      } else {
        const bytes = new TextEncoder().encode(String(part));
        parts.push(bytes);
        size += bytes.byteLength;
      }
    }

    this._size = size;
    this._type = readType(options.type);
    this._parts = parts;
  }

  get type() {
    return this._type;
  }

  get size() {
    return this._size;
  }

  slice(start = 0, end = this.size, type = '') {
    const {
      size,
      _parts
    } = this;
    let offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(limit - offset, 0);
    const blob = new BlobPolyfill([], {
      type
    });

    if (span === 0) {
      return blob;
    }

    let blobSize = 0;
    const blobParts = [];

    for (const part of _parts) {
      const {
        byteLength
      } = part;

      if (offset > 0 && byteLength <= offset) {
        offset -= byteLength;
        limit -= byteLength;
      } else {
        const chunk = part.subarray(offset, Math.min(byteLength, limit));
        blobParts.push(chunk);
        blobSize += chunk.byteLength;
        offset = 0;

        if (blobSize >= span) {
          break;
        }
      }
    }

    blob._parts = blobParts;
    blob._size = blobSize;
    return blob;
  }

  async arrayBuffer() {
    return this._toArrayBuffer();
  }

  async text() {
    const decoder = new TextDecoder();
    let text = '';

    for (const part of this._parts) {
      text += decoder.decode(part);
    }

    return text;
  }

  stream() {
    return new BlobStream(this._parts);
  }

  toString() {
    return '[object Blob]';
  }

  get [Symbol.toStringTag]() {
    return 'Blob';
  }

  _toArrayBuffer() {
    const buffer = new ArrayBuffer(this.size);
    const bytes = new Uint8Array(buffer);
    let offset = 0;

    for (const part of this._parts) {
      bytes.set(part, offset);
      offset += part.byteLength;
    }

    return buffer;
  }

}

function readType(input = '') {
  const type = String(input).toLowerCase();
  return /[^\u0020-\u007E]/.test(type) ? '' : type;
}
//# sourceMappingURL=blob-polyfill.js.map