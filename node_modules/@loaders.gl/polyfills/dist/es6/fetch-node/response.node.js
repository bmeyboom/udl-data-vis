import assert from '../utils/assert';
import { decompressReadStream, concatenateReadStream } from './utils/stream-utils.node';
import Headers from './headers.node';

const isBoolean = x => typeof x === 'boolean';

const isFunction = x => typeof x === 'function';

const isObject = x => x !== null && typeof x === 'object';

const isReadableNodeStream = x => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);

import { Readable } from 'stream';
export default class Response {
  constructor(body, options = {}) {
    const {
      headers,
      status = 200,
      statusText,
      url
    } = options;
    this._url = url;
    this._ok = status === 200;
    this._status = status;
    this._statusText = statusText;
    this._headers = new Headers(headers);
    this.bodyUsed = false;

    if (isReadableNodeStream(body)) {
      this._body = decompressReadStream(body, headers);
    } else if (typeof body === 'string') {
      this._body = Readable.from([new TextEncoder().encode(body)]);
    } else {
      this._body = Readable.from([body || new ArrayBuffer(0)]);
    }
  }

  get ok() {
    return this._ok;
  }

  get status() {
    return this._status;
  }

  get statusText() {
    return this._statusText;
  }

  get url() {
    return this._url;
  }

  get headers() {
    return this._headers;
  }

  get body() {
    assert(!this.bodyUsed);
    assert(isReadableNodeStream(this._body));
    this.bodyUsed = true;
    return this._body;
  }

  async arrayBuffer() {
    if (!isReadableNodeStream(this._body)) {
      return this._body || new ArrayBuffer(0);
    }

    const data = await concatenateReadStream(this._body);
    return data;
  }

  async text() {
    const arrayBuffer = await this.arrayBuffer();
    const textDecoder = new TextDecoder();
    return textDecoder.decode(arrayBuffer);
  }

  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }

  async blob() {
    if (typeof Blob === 'undefined') {
      throw new Error('Blob polyfill not installed');
    }

    return new Blob([await this.arrayBuffer()]);
  }

}
//# sourceMappingURL=response.node.js.map