{"version":3,"sources":["../../../src/fetch-node/response.node.js"],"names":["assert","decompressReadStream","concatenateReadStream","Headers","isBoolean","x","isFunction","isObject","isReadableNodeStream","read","pipe","readable","Readable","Response","constructor","body","options","headers","status","statusText","url","_url","_ok","_status","_statusText","_headers","bodyUsed","_body","from","TextEncoder","encode","ArrayBuffer","ok","arrayBuffer","data","text","textDecoder","TextDecoder","decode","json","JSON","parse","blob","Blob","Error"],"mappings":"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","sourcesContent":["/* global TextDecoder, TextEncoder, Blob */\nimport assert from '../utils/assert';\nimport {decompressReadStream, concatenateReadStream} from './utils/stream-utils.node';\nimport Headers from './headers.node';\n\nconst isBoolean = x => typeof x === 'boolean';\nconst isFunction = x => typeof x === 'function';\nconst isObject = x => x !== null && typeof x === 'object';\nconst isReadableNodeStream = x =>\n  isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);\n\n/**\n * Polyfill for Browser Response\n *\n * Under Node.js we return a mock \"fetch response object\"\n * so that apps can use the same API as in the browser.\n *\n * Note: This is intended to be a \"lightweight\" implementation and will have limitations.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/Response\n */\nimport {Readable} from 'stream';\n\nexport default class Response {\n  // TODO - handle ArrayBuffer, ArrayBufferView, Buffer\n  constructor(body, options = {}) {\n    const {headers, status = 200, statusText, url} = options;\n\n    this._url = url;\n    this._ok = status === 200;\n    this._status = status; // TODO - handle errors and set status\n    this._statusText = statusText;\n    this._headers = new Headers(headers);\n    this.bodyUsed = false;\n\n    // Check for content-encoding and create a decompression stream\n    if (isReadableNodeStream(body)) {\n      this._body = decompressReadStream(body, headers);\n    } else if (typeof body === 'string') {\n      this._body = Readable.from([new TextEncoder().encode(body)]);\n    } else {\n      this._body = Readable.from([body || new ArrayBuffer(0)]);\n    }\n  }\n\n  // Subset of Properties\n\n  get ok() {\n    return this._ok;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  get statusText() {\n    return this._statusText;\n  }\n\n  get url() {\n    return this._url;\n  }\n\n  get headers() {\n    return this._headers;\n  }\n\n  // Returns a readable stream to the \"body\" of the response (or file)\n  get body() {\n    assert(!this.bodyUsed);\n    assert(isReadableNodeStream(this._body)); // Not implemented: conversion of ArrayBuffer etc to stream\n    this.bodyUsed = true;\n    return this._body;\n  }\n\n  // Subset of Methods\n\n  async arrayBuffer() {\n    if (!isReadableNodeStream(this._body)) {\n      return this._body || new ArrayBuffer(0);\n    }\n    const data = await concatenateReadStream(this._body);\n    return data;\n  }\n\n  async text() {\n    const arrayBuffer = await this.arrayBuffer();\n    const textDecoder = new TextDecoder();\n    return textDecoder.decode(arrayBuffer);\n  }\n\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n\n  async blob() {\n    if (typeof Blob === 'undefined') {\n      throw new Error('Blob polyfill not installed');\n    }\n    return new Blob([await this.arrayBuffer()]);\n  }\n}\n"],"file":"response.node.js"}