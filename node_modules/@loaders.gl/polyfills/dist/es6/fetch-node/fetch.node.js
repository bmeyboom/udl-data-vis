import fs from 'fs';
import Response from './response.node';
import Headers from './headers.node';
import { decodeDataUri } from './utils/decode-data-uri.node';
import { createReadStream } from './utils/stream-utils.node';

const isDataURL = url => url.startsWith('data:');

const isRequestURL = url => url.startsWith('http:') || url.startsWith('https:');

export default async function fetchNode(url, options) {
  try {
    if (isDataURL(url)) {
      const {
        arrayBuffer,
        mimeType
      } = decodeDataUri(url);
      const response = new Response(arrayBuffer, {
        headers: {
          'content-type': mimeType,
          url
        }
      });
      return response;
    }

    const syntheticResponseHeaders = {};
    const originalUrl = url;

    if (url.endsWith('.gz')) {
      url = url.slice(0, -3);
      syntheticResponseHeaders['content-encoding'] = 'gzip';
    }

    const body = await createReadStream(originalUrl, options);
    const headers = getHeaders(url, body, syntheticResponseHeaders);
    const {
      status,
      statusText
    } = getStatus(body);
    return new Response(body, {
      headers,
      status,
      statusText,
      url
    });
  } catch (error) {
    return new Response(null, {
      status: 400,
      statusText: String(error),
      url
    });
  }
}

function getStatus(httpResponse) {
  if (httpResponse.statusCode) {
    return {
      status: httpResponse.statusCode,
      statusText: httpResponse.statusMessage || 'NA'
    };
  }

  return {
    status: 200,
    statusText: 'OK'
  };
}

function getHeaders(url, httpResponse, additionalHeaders = {}) {
  const headers = {};

  if (httpResponse && httpResponse.headers) {
    const httpHeaders = httpResponse.headers;

    for (const key in httpHeaders) {
      const header = httpHeaders[key];
      headers[key.toLowerCase()] = String(header);
    }
  }

  if (!headers['content-length']) {
    const contentLength = getContentLength(url);

    if (Number.isFinite(contentLength)) {
      headers['content-length'] = contentLength;
    }
  }

  Object.assign(headers, additionalHeaders);
  return new Headers(headers);
}

function getContentLength(url) {
  if (isRequestURL(url)) {
    return null;
  } else if (isDataURL(url)) {
    return url.length - 'data:'.length;
  }

  try {
    const noqueryUrl = url.split('?')[0];
    const stats = fs.statSync(noqueryUrl);
    return stats.size;
  } catch (error) {}

  return null;
}
//# sourceMappingURL=fetch.node.js.map