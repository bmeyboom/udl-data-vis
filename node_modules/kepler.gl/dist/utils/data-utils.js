"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unique = unique;
exports.findMapBounds = findMapBounds;
exports.getLatLngBounds = getLatLngBounds;
exports.clamp = clamp;
exports.getSampleData = getSampleData;
exports.timeToUnixMilli = timeToUnixMilli;
exports.maybeToDate = maybeToDate;
exports.notNullorUndefined = notNullorUndefined;
exports.isNumber = isNumber;
exports.isPlainObject = isPlainObject;
exports.numberSort = numberSort;
exports.getSortingFunction = getSortingFunction;
exports.preciseRound = preciseRound;
exports.getRoundingDecimalFromStep = getRoundingDecimalFromStep;
exports.snapToMarks = snapToMarks;
exports.normalizeSliderValue = normalizeSliderValue;
exports.roundValToStep = roundValToStep;
exports.getFormatter = getFormatter;
exports.applyDefaultFormat = applyDefaultFormat;
exports.getBooleanFormatter = getBooleanFormatter;
exports.applyCustomFormat = applyCustomFormat;
exports.datetimeFormatter = datetimeFormatter;
exports.arrayMove = exports.parseFieldValue = exports.FIELD_DISPLAY_FORMAT = exports.defaultFormatter = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _assert = _interopRequireDefault(require("assert"));

var _defaultSettings = require("../constants/default-settings");

var _tooltip = require("../constants/tooltip");

var _d3Format = require("d3-format");

var _d3Array = require("d3-array");

var _momentTimezone = _interopRequireDefault(require("moment-timezone"));

var _FIELD_DISPLAY_FORMAT;

var MAX_LATITUDE = 90;
var MIN_LATITUDE = -90;
var MAX_LONGITUDE = 180;
var MIN_LONGITUDE = -180;
/**
 * simple getting unique values of an array
 *
 * @param {array} values
 * @returns {array} unique values
 */

function unique(values) {
  var results = [];
  values.forEach(function (v) {
    if (!results.includes(v) && notNullorUndefined(v)) {
      results.push(v);
    }
  });
  return results;
}
/* eslint-disable max-statements */

/**
 * return center of map from given points
 * @param {array} layers
 * @returns {object} coordinates of map center, empty if not found
 */


function findMapBounds(layers) {
  // find bounds in formatted layerData
  // take ALL layers into account when finding map bounds
  var availableLayerBounds = layers.reduce(function (res, l) {
    if (l.meta && l.meta.bounds) {
      res.push(l.meta.bounds);
    }

    return res;
  }, []); // return null if no layer is available

  if (availableLayerBounds.length === 0) {
    return null;
  } // merge bounds in each layer


  var newBounds = availableLayerBounds.reduce(function (res, b) {
    return [Math.min(res[0], b[0]), Math.min(res[1], b[1]), Math.max(res[2], b[2]), Math.max(res[3], b[3])];
  }, [MAX_LONGITUDE, MAX_LATITUDE, MIN_LONGITUDE, MIN_LATITUDE]);
  return newBounds;
}
/* eslint-enable max-statements */


function getLatLngBounds(points, idx, limit) {
  var lats = points.map(function (d) {
    return Array.isArray(d) && d[idx];
  }).filter(Number.isFinite).sort(numberSort);

  if (!lats.length) {
    return null;
  } // clamp to limit


  return [Math.max(lats[0], limit[0]), Math.min(lats[lats.length - 1], limit[1])];
}

function clamp(_ref, val) {
  var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
      min = _ref2[0],
      max = _ref2[1];

  return val <= min ? min : val >= max ? max : val;
}

function getSampleData(data) {
  var sampleSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  var getValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (d) {
    return d;
  };
  var sampleStep = Math.max(Math.floor(data.length / sampleSize), 1);
  var output = [];

  for (var i = 0; i < data.length; i += sampleStep) {
    output.push(getValue(data[i]));
  }

  return output;
}
/**
 * Convert different time format to unix milliseconds
 * @type {typeof import('./data-utils').timeToUnixMilli}
 */


function timeToUnixMilli(value, format) {
  if (notNullorUndefined(value)) {
    return typeof value === 'string' ? _momentTimezone["default"].utc(value, format).valueOf() : format === 'x' ? value * 1000 : value;
  }

  return null;
}
/**
 *
 * @type {typeof import('./data-utils').maybeToDate}
 */


function maybeToDate(isTime, fieldIdx, format, d) {
  if (isTime) {
    return timeToUnixMilli(d[fieldIdx], format);
  }

  return d[fieldIdx];
}
/**
 * whether null or undefined
 * @type {typeof import('./data-utils').notNullorUndefined}
 */


function notNullorUndefined(d) {
  return d !== undefined && d !== null;
}
/**
 * Whether d is a number, this filtered out NaN as well
 * @type {typeof import('./data-utils').notNullorUndefined}
 */


function isNumber(d) {
  return Number.isFinite(d);
}
/**
 * whether null or undefined
 */


function isPlainObject(obj) {
  return obj === Object(obj) && typeof obj !== 'function' && !Array.isArray(obj);
}
/**
 * @type {typeof import('./data-utils').numberSort}
 */


function numberSort(a, b) {
  return a - b;
}
/**
 * @type {typeof import('./data-utils').getSortingFunction}
 */


function getSortingFunction(fieldType) {
  switch (fieldType) {
    case _defaultSettings.ALL_FIELD_TYPES.real:
    case _defaultSettings.ALL_FIELD_TYPES.integer:
    case _defaultSettings.ALL_FIELD_TYPES.timestamp:
      return numberSort;

    default:
      return undefined;
  }
}
/**
 * round number with exact number of decimals
 * return as a string
 * @type {typeof import('./data-utils').preciseRound}
 */


function preciseRound(num, decimals) {
  var t = Math.pow(10, decimals);
  return (Math.round(num * t + (decimals > 0 ? 1 : 0) * (Math.sign(num) * (10 / Math.pow(100, decimals)))) / t).toFixed(decimals);
}
/**
 * get number of decimals to round to for slider from step
 * @param {number} step
 * @returns {number} - number of decimal
 */


function getRoundingDecimalFromStep(step) {
  if (isNaN(step)) {
    (0, _assert["default"])('step is not a number');
    (0, _assert["default"])(step);
  }

  var splitZero = step.toString().split('.');

  if (splitZero.length === 1) {
    return 0;
  }

  return splitZero[1].length;
}
/**
 * Use in slider, given a number and an array of numbers, return the nears number from the array
 * @type {typeof import('./data-utils').snapToMarks}
 * @param value
 * @param marks
 */


function snapToMarks(value, marks) {
  // always use bin x0
  var i = (0, _d3Array.bisectLeft)(marks, value);

  if (i === 0) {
    return marks[i];
  } else if (i === marks.length) {
    return marks[i - 1];
  }

  var idx = marks[i] - value < value - marks[i - 1] ? i : i - 1;
  return marks[idx];
}
/**
 * If marks is provided, snap to marks, if not normalize to step
 * @type {typeof import('./data-utils').normalizeSliderValue}
 * @param val
 * @param minValue
 * @param step
 * @param marks
 */


function normalizeSliderValue(val, minValue, step, marks) {
  if (marks && marks.length) {
    return snapToMarks(val, marks);
  }

  return roundValToStep(minValue, step, val);
}
/**
 * round the value to step for the slider
 * @type {typeof import('./data-utils').roundValToStep}
 * @param minValue
 * @param step
 * @param val
 * @returns - rounded number
 */


function roundValToStep(minValue, step, val) {
  if (!isNumber(step) || !isNumber(minValue)) {
    return val;
  }

  var decimal = getRoundingDecimalFromStep(step);
  var steps = Math.floor((val - minValue) / step);
  var remain = val - (steps * step + minValue); // has to round because javascript turns 0.1 into 0.9999999999999987

  remain = Number(preciseRound(remain, 8));
  var closest;

  if (remain === 0) {
    closest = val;
  } else if (remain < step / 2) {
    closest = steps * step + minValue;
  } else {
    closest = (steps + 1) * step + minValue;
  } // precise round return a string rounded to the defined decimal


  var rounded = preciseRound(closest, decimal);
  return Number(rounded);
}
/**
 * Get the value format based on field and format options
 * Used in render tooltip value
 * @type {typeof import('./data-utils').defaultFormatter}
 */


var defaultFormatter = function defaultFormatter(v) {
  return notNullorUndefined(v) ? String(v) : '';
};

exports.defaultFormatter = defaultFormatter;
var FIELD_DISPLAY_FORMAT = (_FIELD_DISPLAY_FORMAT = {}, (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.string, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.timestamp, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.integer, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.real, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES["boolean"], defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.date, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.geojson, function (d) {
  return typeof d === 'string' ? d : isPlainObject(d) ? JSON.stringify(d) : Array.isArray(d) ? "[".concat(String(d), "]") : '';
}), _FIELD_DISPLAY_FORMAT);
/**
 * Parse field value and type and return a string representation
 * @type {typeof import('./data-utils').parseFieldValue}
 */

exports.FIELD_DISPLAY_FORMAT = FIELD_DISPLAY_FORMAT;

var parseFieldValue = function parseFieldValue(value, type) {
  if (!notNullorUndefined(value)) {
    return '';
  }

  return FIELD_DISPLAY_FORMAT[type] ? FIELD_DISPLAY_FORMAT[type](value) : String(value);
};

exports.parseFieldValue = parseFieldValue;

var arrayMoveMutate = function arrayMoveMutate(array, from, to) {
  array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);
};
/**
 *
 * @param {*} array
 * @param {*} from
 * @param {*} to
 */


var arrayMove = function arrayMove(array, from, to) {
  array = array.slice();
  arrayMoveMutate(array, from, to);
  return array;
};
/**
 * Get the value format based on field and format options
 * Used in render tooltip value
 * @type {typeof import('./data-utils').getFormatter}
 * @param format
 * @param field
 */


exports.arrayMove = arrayMove;

function getFormatter(format, field) {
  if (!format) {
    return defaultFormatter;
  }

  var tooltipFormat = Object.values(_tooltip.TOOLTIP_FORMATS).find(function (f) {
    return f[_tooltip.TOOLTIP_KEY] === format;
  });

  if (tooltipFormat) {
    return applyDefaultFormat(tooltipFormat);
  } else if (typeof format === 'string' && field) {
    return applyCustomFormat(format, field);
  }

  return defaultFormatter;
}

function applyDefaultFormat(tooltipFormat) {
  if (!tooltipFormat || !tooltipFormat.format) {
    return defaultFormatter;
  }

  switch (tooltipFormat.type) {
    case _tooltip.TOOLTIP_FORMAT_TYPES.DECIMAL:
      return (0, _d3Format.format)(tooltipFormat.format);

    case _tooltip.TOOLTIP_FORMAT_TYPES.DATE:
    case _tooltip.TOOLTIP_FORMAT_TYPES.DATE_TIME:
      return datetimeFormatter(null)(tooltipFormat.format);

    case _tooltip.TOOLTIP_FORMAT_TYPES.PERCENTAGE:
      return function (v) {
        return "".concat((0, _d3Format.format)(_tooltip.TOOLTIP_FORMATS.DECIMAL_DECIMAL_FIXED_2.format)(v), "%");
      };

    case _tooltip.TOOLTIP_FORMAT_TYPES.BOOLEAN:
      return getBooleanFormatter(tooltipFormat.format);

    default:
      return defaultFormatter;
  }
}

function getBooleanFormatter(format) {
  switch (format) {
    case '01':
      return function (v) {
        return v ? '1' : '0';
      };

    case 'yn':
      return function (v) {
        return v ? 'yes' : 'no';
      };

    default:
      return defaultFormatter;
  }
} // Allow user to specify custom tooltip format via config


function applyCustomFormat(format, field) {
  switch (field.type) {
    case _defaultSettings.ALL_FIELD_TYPES.real:
    case _defaultSettings.ALL_FIELD_TYPES.integer:
      return (0, _d3Format.format)(format);

    case _defaultSettings.ALL_FIELD_TYPES.date:
    case _defaultSettings.ALL_FIELD_TYPES.timestamp:
      return datetimeFormatter(null)(format);

    default:
      return function (v) {
        return v;
      };
  }
}
/**
 * Format epoch milliseconds with a format string
 * @type {typeof import('./data-utils').datetimeFormatter} timezone
 */


function datetimeFormatter(timezone) {
  return timezone ? function (format) {
    return function (ts) {
      return _momentTimezone["default"].utc(ts).tz(timezone).format(format);
    };
  } : function (format) {
    return function (ts) {
      return _momentTimezone["default"].utc(ts).format(format);
    };
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9kYXRhLXV0aWxzLmpzIl0sIm5hbWVzIjpbIk1BWF9MQVRJVFVERSIsIk1JTl9MQVRJVFVERSIsIk1BWF9MT05HSVRVREUiLCJNSU5fTE9OR0lUVURFIiwidW5pcXVlIiwidmFsdWVzIiwicmVzdWx0cyIsImZvckVhY2giLCJ2IiwiaW5jbHVkZXMiLCJub3ROdWxsb3JVbmRlZmluZWQiLCJwdXNoIiwiZmluZE1hcEJvdW5kcyIsImxheWVycyIsImF2YWlsYWJsZUxheWVyQm91bmRzIiwicmVkdWNlIiwicmVzIiwibCIsIm1ldGEiLCJib3VuZHMiLCJsZW5ndGgiLCJuZXdCb3VuZHMiLCJiIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldExhdExuZ0JvdW5kcyIsInBvaW50cyIsImlkeCIsImxpbWl0IiwibGF0cyIsIm1hcCIsImQiLCJBcnJheSIsImlzQXJyYXkiLCJmaWx0ZXIiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInNvcnQiLCJudW1iZXJTb3J0IiwiY2xhbXAiLCJ2YWwiLCJnZXRTYW1wbGVEYXRhIiwiZGF0YSIsInNhbXBsZVNpemUiLCJnZXRWYWx1ZSIsInNhbXBsZVN0ZXAiLCJmbG9vciIsIm91dHB1dCIsImkiLCJ0aW1lVG9Vbml4TWlsbGkiLCJ2YWx1ZSIsImZvcm1hdCIsIm1vbWVudCIsInV0YyIsInZhbHVlT2YiLCJtYXliZVRvRGF0ZSIsImlzVGltZSIsImZpZWxkSWR4IiwidW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwiT2JqZWN0IiwiYSIsImdldFNvcnRpbmdGdW5jdGlvbiIsImZpZWxkVHlwZSIsIkFMTF9GSUVMRF9UWVBFUyIsInJlYWwiLCJpbnRlZ2VyIiwidGltZXN0YW1wIiwicHJlY2lzZVJvdW5kIiwibnVtIiwiZGVjaW1hbHMiLCJ0IiwicG93Iiwicm91bmQiLCJzaWduIiwidG9GaXhlZCIsImdldFJvdW5kaW5nRGVjaW1hbEZyb21TdGVwIiwic3RlcCIsImlzTmFOIiwic3BsaXRaZXJvIiwidG9TdHJpbmciLCJzcGxpdCIsInNuYXBUb01hcmtzIiwibWFya3MiLCJub3JtYWxpemVTbGlkZXJWYWx1ZSIsIm1pblZhbHVlIiwicm91bmRWYWxUb1N0ZXAiLCJkZWNpbWFsIiwic3RlcHMiLCJyZW1haW4iLCJjbG9zZXN0Iiwicm91bmRlZCIsImRlZmF1bHRGb3JtYXR0ZXIiLCJTdHJpbmciLCJGSUVMRF9ESVNQTEFZX0ZPUk1BVCIsInN0cmluZyIsImRhdGUiLCJnZW9qc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlRmllbGRWYWx1ZSIsInR5cGUiLCJhcnJheU1vdmVNdXRhdGUiLCJhcnJheSIsImZyb20iLCJ0byIsInNwbGljZSIsImFycmF5TW92ZSIsInNsaWNlIiwiZ2V0Rm9ybWF0dGVyIiwiZmllbGQiLCJ0b29sdGlwRm9ybWF0IiwiVE9PTFRJUF9GT1JNQVRTIiwiZmluZCIsImYiLCJUT09MVElQX0tFWSIsImFwcGx5RGVmYXVsdEZvcm1hdCIsImFwcGx5Q3VzdG9tRm9ybWF0IiwiVE9PTFRJUF9GT1JNQVRfVFlQRVMiLCJERUNJTUFMIiwiREFURSIsIkRBVEVfVElNRSIsImRhdGV0aW1lRm9ybWF0dGVyIiwiUEVSQ0VOVEFHRSIsIkRFQ0lNQUxfREVDSU1BTF9GSVhFRF8yIiwiQk9PTEVBTiIsImdldEJvb2xlYW5Gb3JtYXR0ZXIiLCJ0aW1lem9uZSIsInRzIiwidHoiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUEsSUFBTUEsWUFBWSxHQUFHLEVBQXJCO0FBQ0EsSUFBTUMsWUFBWSxHQUFHLENBQUMsRUFBdEI7QUFDQSxJQUFNQyxhQUFhLEdBQUcsR0FBdEI7QUFDQSxJQUFNQyxhQUFhLEdBQUcsQ0FBQyxHQUF2QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTQyxNQUFULENBQWdCQyxNQUFoQixFQUF3QjtBQUM3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QTVDLENBQUM7QUFBQSxlQUFJQSxDQUFKO0FBQUEsT0FBUjtBQVJKO0FBVUQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU3FILGlCQUFULENBQTJCSyxRQUEzQixFQUFxQztBQUMxQyxTQUFPQSxRQUFRLEdBQ1gsVUFBQTlFLE1BQU07QUFBQSxXQUFJLFVBQUErRSxFQUFFO0FBQUEsYUFDVjlFLDJCQUNHQyxHQURILENBQ082RSxFQURQLEVBRUdDLEVBRkgsQ0FFTUYsUUFGTixFQUdHOUUsTUFISCxDQUdVQSxNQUhWLENBRFU7QUFBQSxLQUFOO0FBQUEsR0FESyxHQU1YLFVBQUFBLE1BQU07QUFBQSxXQUFJLFVBQUErRSxFQUFFO0FBQUEsYUFBSTlFLDJCQUFPQyxHQUFQLENBQVc2RSxFQUFYLEVBQWUvRSxNQUFmLENBQXNCQSxNQUF0QixDQUFKO0FBQUEsS0FBTjtBQUFBLEdBTlY7QUFPRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7QUxMX0ZJRUxEX1RZUEVTfSBmcm9tICdjb25zdGFudHMvZGVmYXVsdC1zZXR0aW5ncyc7XG5pbXBvcnQge1RPT0xUSVBfRk9STUFUUywgVE9PTFRJUF9GT1JNQVRfVFlQRVMsIFRPT0xUSVBfS0VZfSBmcm9tICdjb25zdGFudHMvdG9vbHRpcCc7XG5pbXBvcnQge2Zvcm1hdCBhcyBkM0Zvcm1hdH0gZnJvbSAnZDMtZm9ybWF0JztcbmltcG9ydCB7YmlzZWN0TGVmdH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQtdGltZXpvbmUnO1xuXG5jb25zdCBNQVhfTEFUSVRVREUgPSA5MDtcbmNvbnN0IE1JTl9MQVRJVFVERSA9IC05MDtcbmNvbnN0IE1BWF9MT05HSVRVREUgPSAxODA7XG5jb25zdCBNSU5fTE9OR0lUVURFID0gLTE4MDtcblxuLyoqXG4gKiBzaW1wbGUgZ2V0dGluZyB1bmlxdWUgdmFsdWVzIG9mIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIHthcnJheX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7YXJyYXl9IHVuaXF1ZSB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZSh2YWx1ZXMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICB2YWx1ZXMuZm9yRWFjaCh2ID0+IHtcbiAgICBpZiAoIXJlc3VsdHMuaW5jbHVkZXModikgJiYgbm90TnVsbG9yVW5kZWZpbmVkKHYpKSB7XG4gICAgICByZXN1bHRzLnB1c2godik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbi8qKlxuICogcmV0dXJuIGNlbnRlciBvZiBtYXAgZnJvbSBnaXZlbiBwb2ludHNcbiAqIEBwYXJhbSB7YXJyYXl9IGxheWVyc1xuICogQHJldHVybnMge29iamVjdH0gY29vcmRpbmF0ZXMgb2YgbWFwIGNlbnRlciwgZW1wdHkgaWYgbm90IGZvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWFwQm91bmRzKGxheWVycykge1xuICAvLyBmaW5kIGJvdW5kcyBpbiBmb3JtYXR0ZWQgbGF5ZXJEYXRhXG4gIC8vIHRha2UgQUxMIGxheWVycyBpbnRvIGFjY291bnQgd2hlbiBmaW5kaW5nIG1hcCBib3VuZHNcbiAgY29uc3QgYXZhaWxhYmxlTGF5ZXJCb3VuZHMgPSBsYXllcnMucmVkdWNlKChyZXMsIGwpID0+IHtcbiAgICBpZiAobC5tZXRhICYmIGwubWV0YS5ib3VuZHMpIHtcbiAgICAgIHJlcy5wdXNoKGwubWV0YS5ib3VuZHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9LCBbXSk7XG4gIC8vIHJldHVybiBudWxsIGlmIG5vIGxheWVyIGlzIGF2YWlsYWJsZVxuICBpZiAoYXZhaWxhYmxlTGF5ZXJCb3VuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gbWVyZ2UgYm91bmRzIGluIGVhY2ggbGF5ZXJcbiAgY29uc3QgbmV3Qm91bmRzID0gYXZhaWxhYmxlTGF5ZXJCb3VuZHMucmVkdWNlKFxuICAgIChyZXMsIGIpID0+IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgubWluKHJlc1swXSwgYlswXSksXG4gICAgICAgIE1hdGgubWluKHJlc1sxXSwgYlsxXSksXG4gICAgICAgIE1hdGgubWF4KHJlc1syXSwgYlsyXSksXG4gICAgICAgIE1hdGgubWF4KHJlc1szXSwgYlszXSlcbiAgICAgIF07XG4gICAgfSxcbiAgICBbTUFYX0xPTkdJVFVERSwgTUFYX0xBVElUVURFLCBNSU5fTE9OR0lUVURFLCBNSU5fTEFUSVRVREVdXG4gICk7XG4gIHJldHVybiBuZXdCb3VuZHM7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXRMbmdCb3VuZHMocG9pbnRzLCBpZHgsIGxpbWl0KSB7XG4gIGNvbnN0IGxhdHMgPSBwb2ludHNcbiAgICAubWFwKGQgPT4gQXJyYXkuaXNBcnJheShkKSAmJiBkW2lkeF0pXG4gICAgLmZpbHRlcihOdW1iZXIuaXNGaW5pdGUpXG4gICAgLnNvcnQobnVtYmVyU29ydCk7XG5cbiAgaWYgKCFsYXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gY2xhbXAgdG8gbGltaXRcbiAgcmV0dXJuIFtNYXRoLm1heChsYXRzWzBdLCBsaW1pdFswXSksIE1hdGgubWluKGxhdHNbbGF0cy5sZW5ndGggLSAxXSwgbGltaXRbMV0pXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKFttaW4sIG1heF0sIHZhbCkge1xuICByZXR1cm4gdmFsIDw9IG1pbiA/IG1pbiA6IHZhbCA+PSBtYXggPyBtYXggOiB2YWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTYW1wbGVEYXRhKGRhdGEsIHNhbXBsZVNpemUgPSA1MDAsIGdldFZhbHVlID0gZCA9PiBkKSB7XG4gIGNvbnN0IHNhbXBsZVN0ZXAgPSBNYXRoLm1heChNYXRoLmZsb29yKGRhdGEubGVuZ3RoIC8gc2FtcGxlU2l6ZSksIDEpO1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSBzYW1wbGVTdGVwKSB7XG4gICAgb3V0cHV0LnB1c2goZ2V0VmFsdWUoZGF0YVtpXSkpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGRpZmZlcmVudCB0aW1lIGZvcm1hdCB0byB1bml4IG1pbGxpc2Vjb25kc1xuICogQHR5cGUge3R5cGVvZiBpbXBvcnQoJy4vZGF0YS11dGlscycpLnRpbWVUb1VuaXhNaWxsaX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVUb1VuaXhNaWxsaSh2YWx1ZSwgZm9ybWF0KSB7XG4gIGlmIChub3ROdWxsb3JVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbiAgICAgID8gbW9tZW50LnV0Yyh2YWx1ZSwgZm9ybWF0KS52YWx1ZU9mKClcbiAgICAgIDogZm9ybWF0ID09PSAneCdcbiAgICAgID8gdmFsdWUgKiAxMDAwXG4gICAgICA6IHZhbHVlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqXG4gKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnLi9kYXRhLXV0aWxzJykubWF5YmVUb0RhdGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVRvRGF0ZShpc1RpbWUsIGZpZWxkSWR4LCBmb3JtYXQsIGQpIHtcbiAgaWYgKGlzVGltZSkge1xuICAgIHJldHVybiB0aW1lVG9Vbml4TWlsbGkoZFtmaWVsZElkeF0sIGZvcm1hdCk7XG4gIH1cblxuICByZXR1cm4gZFtmaWVsZElkeF07XG59XG5cbi8qKlxuICogd2hldGhlciBudWxsIG9yIHVuZGVmaW5lZFxuICogQHR5cGUge3R5cGVvZiBpbXBvcnQoJy4vZGF0YS11dGlscycpLm5vdE51bGxvclVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdE51bGxvclVuZGVmaW5lZChkKSB7XG4gIHJldHVybiBkICE9PSB1bmRlZmluZWQgJiYgZCAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIGQgaXMgYSBudW1iZXIsIHRoaXMgZmlsdGVyZWQgb3V0IE5hTiBhcyB3ZWxsXG4gKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnLi9kYXRhLXV0aWxzJykubm90TnVsbG9yVW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIoZCkge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKGQpO1xufVxuLyoqXG4gKiB3aGV0aGVyIG51bGwgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKSAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nICYmICFBcnJheS5pc0FycmF5KG9iaik7XG59XG5cbi8qKlxuICogQHR5cGUge3R5cGVvZiBpbXBvcnQoJy4vZGF0YS11dGlscycpLm51bWJlclNvcnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJTb3J0KGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG4vKipcbiAqIEB0eXBlIHt0eXBlb2YgaW1wb3J0KCcuL2RhdGEtdXRpbHMnKS5nZXRTb3J0aW5nRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb3J0aW5nRnVuY3Rpb24oZmllbGRUeXBlKSB7XG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBBTExfRklFTERfVFlQRVMucmVhbDpcbiAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyOlxuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnRpbWVzdGFtcDpcbiAgICAgIHJldHVybiBudW1iZXJTb3J0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogcm91bmQgbnVtYmVyIHdpdGggZXhhY3QgbnVtYmVyIG9mIGRlY2ltYWxzXG4gKiByZXR1cm4gYXMgYSBzdHJpbmdcbiAqIEB0eXBlIHt0eXBlb2YgaW1wb3J0KCcuL2RhdGEtdXRpbHMnKS5wcmVjaXNlUm91bmR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVjaXNlUm91bmQobnVtLCBkZWNpbWFscykge1xuICBjb25zdCB0ID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgcmV0dXJuIChcbiAgICBNYXRoLnJvdW5kKFxuICAgICAgbnVtICogdCArIChkZWNpbWFscyA+IDAgPyAxIDogMCkgKiAoTWF0aC5zaWduKG51bSkgKiAoMTAgLyBNYXRoLnBvdygxMDAsIGRlY2ltYWxzKSkpXG4gICAgKSAvIHRcbiAgKS50b0ZpeGVkKGRlY2ltYWxzKTtcbn1cblxuLyoqXG4gKiBnZXQgbnVtYmVyIG9mIGRlY2ltYWxzIHRvIHJvdW5kIHRvIGZvciBzbGlkZXIgZnJvbSBzdGVwXG4gKiBAcGFyYW0ge251bWJlcn0gc3RlcFxuICogQHJldHVybnMge251bWJlcn0gLSBudW1iZXIgb2YgZGVjaW1hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91bmRpbmdEZWNpbWFsRnJvbVN0ZXAoc3RlcCkge1xuICBpZiAoaXNOYU4oc3RlcCkpIHtcbiAgICBhc3NlcnQoJ3N0ZXAgaXMgbm90IGEgbnVtYmVyJyk7XG4gICAgYXNzZXJ0KHN0ZXApO1xuICB9XG5cbiAgY29uc3Qgc3BsaXRaZXJvID0gc3RlcC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gIGlmIChzcGxpdFplcm8ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHNwbGl0WmVyb1sxXS5sZW5ndGg7XG59XG5cbi8qKlxuICogVXNlIGluIHNsaWRlciwgZ2l2ZW4gYSBudW1iZXIgYW5kIGFuIGFycmF5IG9mIG51bWJlcnMsIHJldHVybiB0aGUgbmVhcnMgbnVtYmVyIGZyb20gdGhlIGFycmF5XG4gKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnLi9kYXRhLXV0aWxzJykuc25hcFRvTWFya3N9XG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBtYXJrc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcFRvTWFya3ModmFsdWUsIG1hcmtzKSB7XG4gIC8vIGFsd2F5cyB1c2UgYmluIHgwXG4gIGNvbnN0IGkgPSBiaXNlY3RMZWZ0KG1hcmtzLCB2YWx1ZSk7XG4gIGlmIChpID09PSAwKSB7XG4gICAgcmV0dXJuIG1hcmtzW2ldO1xuICB9IGVsc2UgaWYgKGkgPT09IG1hcmtzLmxlbmd0aCkge1xuICAgIHJldHVybiBtYXJrc1tpIC0gMV07XG4gIH1cbiAgY29uc3QgaWR4ID0gbWFya3NbaV0gLSB2YWx1ZSA8IHZhbHVlIC0gbWFya3NbaSAtIDFdID8gaSA6IGkgLSAxO1xuICByZXR1cm4gbWFya3NbaWR4XTtcbn1cblxuLyoqXG4gKiBJZiBtYXJrcyBpcyBwcm92aWRlZCwgc25hcCB0byBtYXJrcywgaWYgbm90IG5vcm1hbGl6ZSB0byBzdGVwXG4gKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnLi9kYXRhLXV0aWxzJykubm9ybWFsaXplU2xpZGVyVmFsdWV9XG4gKiBAcGFyYW0gdmFsXG4gKiBAcGFyYW0gbWluVmFsdWVcbiAqIEBwYXJhbSBzdGVwXG4gKiBAcGFyYW0gbWFya3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVNsaWRlclZhbHVlKHZhbCwgbWluVmFsdWUsIHN0ZXAsIG1hcmtzKSB7XG4gIGlmIChtYXJrcyAmJiBtYXJrcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gc25hcFRvTWFya3ModmFsLCBtYXJrcyk7XG4gIH1cblxuICByZXR1cm4gcm91bmRWYWxUb1N0ZXAobWluVmFsdWUsIHN0ZXAsIHZhbCk7XG59XG5cbi8qKlxuICogcm91bmQgdGhlIHZhbHVlIHRvIHN0ZXAgZm9yIHRoZSBzbGlkZXJcbiAqIEB0eXBlIHt0eXBlb2YgaW1wb3J0KCcuL2RhdGEtdXRpbHMnKS5yb3VuZFZhbFRvU3RlcH1cbiAqIEBwYXJhbSBtaW5WYWx1ZVxuICogQHBhcmFtIHN0ZXBcbiAqIEBwYXJhbSB2YWxcbiAqIEByZXR1cm5zIC0gcm91bmRlZCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVmFsVG9TdGVwKG1pblZhbHVlLCBzdGVwLCB2YWwpIHtcbiAgaWYgKCFpc051bWJlcihzdGVwKSB8fCAhaXNOdW1iZXIobWluVmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNvbnN0IGRlY2ltYWwgPSBnZXRSb3VuZGluZ0RlY2ltYWxGcm9tU3RlcChzdGVwKTtcbiAgY29uc3Qgc3RlcHMgPSBNYXRoLmZsb29yKCh2YWwgLSBtaW5WYWx1ZSkgLyBzdGVwKTtcbiAgbGV0IHJlbWFpbiA9IHZhbCAtIChzdGVwcyAqIHN0ZXAgKyBtaW5WYWx1ZSk7XG5cbiAgLy8gaGFzIHRvIHJvdW5kIGJlY2F1c2UgamF2YXNjcmlwdCB0dXJucyAwLjEgaW50byAwLjk5OTk5OTk5OTk5OTk5ODdcbiAgcmVtYWluID0gTnVtYmVyKHByZWNpc2VSb3VuZChyZW1haW4sIDgpKTtcblxuICBsZXQgY2xvc2VzdDtcbiAgaWYgKHJlbWFpbiA9PT0gMCkge1xuICAgIGNsb3Nlc3QgPSB2YWw7XG4gIH0gZWxzZSBpZiAocmVtYWluIDwgc3RlcCAvIDIpIHtcbiAgICBjbG9zZXN0ID0gc3RlcHMgKiBzdGVwICsgbWluVmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY2xvc2VzdCA9IChzdGVwcyArIDEpICogc3RlcCArIG1pblZhbHVlO1xuICB9XG5cbiAgLy8gcHJlY2lzZSByb3VuZCByZXR1cm4gYSBzdHJpbmcgcm91bmRlZCB0byB0aGUgZGVmaW5lZCBkZWNpbWFsXG4gIGNvbnN0IHJvdW5kZWQgPSBwcmVjaXNlUm91bmQoY2xvc2VzdCwgZGVjaW1hbCk7XG5cbiAgcmV0dXJuIE51bWJlcihyb3VuZGVkKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvcm1hdCBiYXNlZCBvbiBmaWVsZCBhbmQgZm9ybWF0IG9wdGlvbnNcbiAqIFVzZWQgaW4gcmVuZGVyIHRvb2x0aXAgdmFsdWVcbiAqIEB0eXBlIHt0eXBlb2YgaW1wb3J0KCcuL2RhdGEtdXRpbHMnKS5kZWZhdWx0Rm9ybWF0dGVyfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEZvcm1hdHRlciA9IHYgPT4gKG5vdE51bGxvclVuZGVmaW5lZCh2KSA/IFN0cmluZyh2KSA6ICcnKTtcblxuZXhwb3J0IGNvbnN0IEZJRUxEX0RJU1BMQVlfRk9STUFUID0ge1xuICBbQUxMX0ZJRUxEX1RZUEVTLnN0cmluZ106IGRlZmF1bHRGb3JtYXR0ZXIsXG4gIFtBTExfRklFTERfVFlQRVMudGltZXN0YW1wXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5yZWFsXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5ib29sZWFuXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5kYXRlXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5nZW9qc29uXTogZCA9PlxuICAgIHR5cGVvZiBkID09PSAnc3RyaW5nJ1xuICAgICAgPyBkXG4gICAgICA6IGlzUGxhaW5PYmplY3QoZClcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkoZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShkKVxuICAgICAgPyBgWyR7U3RyaW5nKGQpfV1gXG4gICAgICA6ICcnXG59O1xuXG4vKipcbiAqIFBhcnNlIGZpZWxkIHZhbHVlIGFuZCB0eXBlIGFuZCByZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIEB0eXBlIHt0eXBlb2YgaW1wb3J0KCcuL2RhdGEtdXRpbHMnKS5wYXJzZUZpZWxkVmFsdWV9XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUZpZWxkVmFsdWUgPSAodmFsdWUsIHR5cGUpID0+IHtcbiAgaWYgKCFub3ROdWxsb3JVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIEZJRUxEX0RJU1BMQVlfRk9STUFUW3R5cGVdID8gRklFTERfRElTUExBWV9GT1JNQVRbdHlwZV0odmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn07XG5cbmNvbnN0IGFycmF5TW92ZU11dGF0ZSA9IChhcnJheSwgZnJvbSwgdG8pID0+IHtcbiAgYXJyYXkuc3BsaWNlKHRvIDwgMCA/IGFycmF5Lmxlbmd0aCArIHRvIDogdG8sIDAsIGFycmF5LnNwbGljZShmcm9tLCAxKVswXSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IGFycmF5XG4gKiBAcGFyYW0geyp9IGZyb21cbiAqIEBwYXJhbSB7Kn0gdG9cbiAqL1xuZXhwb3J0IGNvbnN0IGFycmF5TW92ZSA9IChhcnJheSwgZnJvbSwgdG8pID0+IHtcbiAgYXJyYXkgPSBhcnJheS5zbGljZSgpO1xuICBhcnJheU1vdmVNdXRhdGUoYXJyYXksIGZyb20sIHRvKTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvcm1hdCBiYXNlZCBvbiBmaWVsZCBhbmQgZm9ybWF0IG9wdGlvbnNcbiAqIFVzZWQgaW4gcmVuZGVyIHRvb2x0aXAgdmFsdWVcbiAqIEB0eXBlIHt0eXBlb2YgaW1wb3J0KCcuL2RhdGEtdXRpbHMnKS5nZXRGb3JtYXR0ZXJ9XG4gKiBAcGFyYW0gZm9ybWF0XG4gKiBAcGFyYW0gZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvcm1hdHRlcihmb3JtYXQsIGZpZWxkKSB7XG4gIGlmICghZm9ybWF0KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXI7XG4gIH1cbiAgY29uc3QgdG9vbHRpcEZvcm1hdCA9IE9iamVjdC52YWx1ZXMoVE9PTFRJUF9GT1JNQVRTKS5maW5kKGYgPT4gZltUT09MVElQX0tFWV0gPT09IGZvcm1hdCk7XG5cbiAgaWYgKHRvb2x0aXBGb3JtYXQpIHtcbiAgICByZXR1cm4gYXBwbHlEZWZhdWx0Rm9ybWF0KHRvb2x0aXBGb3JtYXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnICYmIGZpZWxkKSB7XG4gICAgcmV0dXJuIGFwcGx5Q3VzdG9tRm9ybWF0KGZvcm1hdCwgZmllbGQpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRGb3JtYXQodG9vbHRpcEZvcm1hdCkge1xuICBpZiAoIXRvb2x0aXBGb3JtYXQgfHwgIXRvb2x0aXBGb3JtYXQuZm9ybWF0KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXI7XG4gIH1cblxuICBzd2l0Y2ggKHRvb2x0aXBGb3JtYXQudHlwZSkge1xuICAgIGNhc2UgVE9PTFRJUF9GT1JNQVRfVFlQRVMuREVDSU1BTDpcbiAgICAgIHJldHVybiBkM0Zvcm1hdCh0b29sdGlwRm9ybWF0LmZvcm1hdCk7XG4gICAgY2FzZSBUT09MVElQX0ZPUk1BVF9UWVBFUy5EQVRFOlxuICAgIGNhc2UgVE9PTFRJUF9GT1JNQVRfVFlQRVMuREFURV9USU1FOlxuICAgICAgcmV0dXJuIGRhdGV0aW1lRm9ybWF0dGVyKG51bGwpKHRvb2x0aXBGb3JtYXQuZm9ybWF0KTtcbiAgICBjYXNlIFRPT0xUSVBfRk9STUFUX1RZUEVTLlBFUkNFTlRBR0U6XG4gICAgICByZXR1cm4gdiA9PiBgJHtkM0Zvcm1hdChUT09MVElQX0ZPUk1BVFMuREVDSU1BTF9ERUNJTUFMX0ZJWEVEXzIuZm9ybWF0KSh2KX0lYDtcbiAgICBjYXNlIFRPT0xUSVBfRk9STUFUX1RZUEVTLkJPT0xFQU46XG4gICAgICByZXR1cm4gZ2V0Qm9vbGVhbkZvcm1hdHRlcih0b29sdGlwRm9ybWF0LmZvcm1hdCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb29sZWFuRm9ybWF0dGVyKGZvcm1hdCkge1xuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgJzAxJzpcbiAgICAgIHJldHVybiB2ID0+ICh2ID8gJzEnIDogJzAnKTtcbiAgICBjYXNlICd5bic6XG4gICAgICByZXR1cm4gdiA9PiAodiA/ICd5ZXMnIDogJ25vJyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyO1xuICB9XG59XG4vLyBBbGxvdyB1c2VyIHRvIHNwZWNpZnkgY3VzdG9tIHRvb2x0aXAgZm9ybWF0IHZpYSBjb25maWdcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUN1c3RvbUZvcm1hdChmb3JtYXQsIGZpZWxkKSB7XG4gIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnJlYWw6XG4gICAgY2FzZSBBTExfRklFTERfVFlQRVMuaW50ZWdlcjpcbiAgICAgIHJldHVybiBkM0Zvcm1hdChmb3JtYXQpO1xuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLmRhdGU6XG4gICAgY2FzZSBBTExfRklFTERfVFlQRVMudGltZXN0YW1wOlxuICAgICAgcmV0dXJuIGRhdGV0aW1lRm9ybWF0dGVyKG51bGwpKGZvcm1hdCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2ID0+IHY7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXQgZXBvY2ggbWlsbGlzZWNvbmRzIHdpdGggYSBmb3JtYXQgc3RyaW5nXG4gKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnLi9kYXRhLXV0aWxzJykuZGF0ZXRpbWVGb3JtYXR0ZXJ9IHRpbWV6b25lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRldGltZUZvcm1hdHRlcih0aW1lem9uZSkge1xuICByZXR1cm4gdGltZXpvbmVcbiAgICA/IGZvcm1hdCA9PiB0cyA9PlxuICAgICAgICBtb21lbnRcbiAgICAgICAgICAudXRjKHRzKVxuICAgICAgICAgIC50eih0aW1lem9uZSlcbiAgICAgICAgICAuZm9ybWF0KGZvcm1hdClcbiAgICA6IGZvcm1hdCA9PiB0cyA9PiBtb21lbnQudXRjKHRzKS5mb3JtYXQoZm9ybWF0KTtcbn1cbiJdfQ==